<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Modeling · Plasmo.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Plasmo.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li class="is-active"><a class="tocitem" href>Modeling</a><ul class="internal"><li><a class="tocitem" href="#Creating-an-OptiGraph"><span>Creating an OptiGraph</span></a></li><li><a class="tocitem" href="#Adding-OptiNodes"><span>Adding OptiNodes</span></a></li><li><a class="tocitem" href="#Adding-Linking-Constraints-(OptiEdges)"><span>Adding Linking Constraints (OptiEdges)</span></a></li><li><a class="tocitem" href="#Hierarchical-Modeling"><span>Hierarchical Modeling</span></a></li><li><a class="tocitem" href="#Query-OptiGraph-Attributes"><span>Query OptiGraph Attributes</span></a></li><li><a class="tocitem" href="#Methods"><span>Methods</span></a></li></ul></li><li><a class="tocitem" href="../partitioning/">Partitioning and Graph Operations</a></li><li><a class="tocitem" href="../solvers/">Solvers</a></li><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><a class="tocitem" href="../../tutorials/tutorials/">Tutorials</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Modeling</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Modeling</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jalving/Plasmo.jl/blob/master/docs/src/documentation/modeling.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Modeling"><a class="docs-heading-anchor" href="#Modeling">Modeling</a><a id="Modeling-1"></a><a class="docs-heading-anchor-permalink" href="#Modeling" title="Permalink"></a></h1><p>In Plasmo.jl, the primary modeling object is called an <a href="#Plasmo.OptiGraph"><code>OptiGraph</code></a>. The <code>OptiGraph</code> adheres to a graph-based style of modeling that uses nodes and edges to create optimization problems. This graph-based style permits modular model development and makes it possible to capture and represent complex optimization problem structures. An <code>OptiGraph</code> is composed of <a href="#Plasmo.OptiNode"><code>OptiNode</code></a>s which represent individual optimization problems that are connected by <a href="#Plasmo.OptiEdge"><code>OptiEdge</code></a>s which encapsulate <a href="#Plasmo.LinkConstraint"><code>LinkConstraint</code></a>s (i.e. linking constraints that couple optinodes). A key idea behind Plasmo&#39;s&#39; graph-based approach is that it works at a high level of abstraction and uses modular principles and hierarchical modeling to express complex optimization problems. The optimization models created with an optigraph can be used to reveal inherent structures that lend themselves to graph processing tasks such as partitioning.</p><p>The <code>OptiGraph</code> ultimately describes the following mathematical optimization problem:</p><div>\[\begin{aligned}
    \min_{{\{x_n}\}_{n \in \mathcal{N}(\mathcal{G})}} &amp; \quad \sum_{n \in \mathcal{N(\mathcal{G})}} f_n(x_n) \quad &amp; (\textrm{Objective}) \\
    \textrm{s.t.} &amp; \quad x_n \in \mathcal{X}_n,      \quad n \in \mathcal{N(\mathcal{G})}, \quad &amp; (\textrm{Node Constraints})\\
    &amp; \quad g_e(\{x_n\}_{n \in \mathcal{N}(e)}) = 0,  \quad e \in \mathcal{E(\mathcal{G})}. &amp;(\textrm{Link Constraints})
\end{aligned}\]</div><p>In this formulation, <span>$\mathcal{G}$</span> represents the optigraph, <span>${\{x_n}\}_{n \in \mathcal{N}(\mathcal{G})}$</span> describes a collection of decision variables over the set of nodes (optinodes) <span>$\mathcal{N}(\mathcal{G})$</span>, and <span>$x_n$</span> is the set of decision variables on node <span>$n$</span>. The objective function for the optigraph <span>$\mathcal{G}$</span> is given by a linear combination of objective functions on each optinode <span>$f_n(x_n)$</span>, but other formulations are possible. The second equation represents constraints on each optinode <span>$\mathcal{N}(\mathcal{G})$</span>, and the third equation represents the collection of linking constraints which induce optiedges <span>$\mathcal{E}(\mathcal{G})$</span>. The constraints of an optinode <span>$n$</span> are represented by the set <span>$\mathcal{X}_n$</span> while the linking constraints induced by an edge <span>$e$</span> are represented by the vector function <span>$g_e(\{x_n\}_{n \in \mathcal{N}(e)})$</span> (an optiedge can contain multiple linking constraints). This formulation is also visualized by the following figure.</p><img src="../assets/optigraph.svg" alt="optigraph" width="600"/><p>From an implementation standpoint, an <code>OptiGraph</code> contains <code>OptiNode</code> and <code>OptiEdge</code> objects and extends much of the modeling functionality and syntax from <a href="https://github.com/jump-dev/JuMP.jl">JuMP</a>. The <code>OptiNode</code> object encapsulates a <code>Model</code> object from <code>JuMP</code>, and the <code>OptiEdge</code> object encapsulates the linking constraints that define coupling between optinodes.</p><h2 id="Creating-an-OptiGraph"><a class="docs-heading-anchor" href="#Creating-an-OptiGraph">Creating an OptiGraph</a><a id="Creating-an-OptiGraph-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-an-OptiGraph" title="Permalink"></a></h2><p>An <code>OptiGraph</code> does not require any arguments to construct:</p><pre><code class="language-julia-repl">julia&gt; graph1 = OptiGraph()
OptiGraph:
local nodes: 0, total nodes: 0
local link constraints: 0, total link constraints 0
local subgraphs: 0, total subgraphs 0</code></pre><p>An optigraph optimizer can also be specified using <a href="#JuMP.set_optimizer-Tuple{OptiGraph,Any}"><code>JuMP.set_optimizer</code></a> where an optimizer can be any JuMP compatible solver or a custom developed Plasmo.jl solver (see the <a href="../solvers/#Solvers">Solvers</a> section).   For example, we could construct an optigraph that uses the <code>Ipopt.Optimizer</code> from the Ipopt package like following:</p><pre><code class="language-julia">julia&gt; using Ipopt

julia&gt; set_optimizer(graph1,Ipopt.Optimizer)</code></pre><h2 id="Adding-OptiNodes"><a class="docs-heading-anchor" href="#Adding-OptiNodes">Adding OptiNodes</a><a id="Adding-OptiNodes-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-OptiNodes" title="Permalink"></a></h2><p>The most effective way to add optinodes to an optigraph is by using the <a href="#Plasmo.@optinode"><code>@optinode</code></a> macro.  The below piece of code adds the node <code>n1</code> to the optigraph <code>graph1</code>.</p><pre><code class="language-julia-repl">julia&gt; @optinode(graph1,n1)
OptiNode w/ 0 Variable(s)</code></pre><p>It is also possible to create sets of optinodes with a single call to <a href="#Plasmo.@optinode"><code>@optinode</code></a> like shown in the below code snippet. Here, we create two more optinodes which returns the reference <code>nodes</code>. This input produces a <code>JuMP.DenseAxisArray</code> which allows us to refer to each optinode using the produced index sets.  For example, <code>nodes[2]</code> and <code>nodes[3]</code> each return the corresponding optinode.</p><pre><code class="language-julia-repl">julia&gt; @optinode(graph1,nodes[2:3])
1-dimensional DenseAxisArray{OptiNode,1,...} with index sets:
    Dimension 1, 2:3
And data, a 2-element Array{OptiNode,1}:
 OptiNode w/ 0 Variable(s)
 OptiNode w/ 0 Variable(s)

julia&gt; nodes[2]
OptiNode w/ 0 Variable(s)

julia&gt; nodes[3]
OptiNode w/ 0 Variable(s)</code></pre><p>Each optinode can have its underlying model constructed in a modular way.  Here we loop through each optinode in <code>graph1</code> using <a href="#Plasmo.getnodes"><code>getnodes</code></a> and construct its underlying model by adding variables, a constraint, and objective function.</p><pre><code class="language-julia-repl">julia&gt;  for node in getnodes(graph1)
            @variable(node,x &gt;= 0)
            @variable(node, y &gt;= 2)
            @constraint(node,x + y &gt;= 3)
            @objective(node, Min, y)
        end</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The <a href="#Plasmo.OptiNode"><code>OptiNode</code></a> extends <code>JuMP.AbstractModel</code> and supports most of the same JuMP macros. However, extending nonlinear functionality in JuMP is not yet supported, and so  one must use <a href="#Plasmo.@NLnodeconstraint"><code>@NLnodeconstraint</code></a> as opposed <code>@NLconstraint</code> to create nonlinear constraints on an optinode.</p></div></div><p>Variables within an optinode can be accessed directly by indexing the associated symbol.  This enclosed variable space is useful for referencing variables on different optinodes when creating linking constraints or optigraph objective functions.</p><pre><code class="language-julia-repl">julia&gt; n1[:x]
x

julia&gt; nodes[2][:y]
y</code></pre><h2 id="Adding-Linking-Constraints-(OptiEdges)"><a class="docs-heading-anchor" href="#Adding-Linking-Constraints-(OptiEdges)">Adding Linking Constraints (OptiEdges)</a><a id="Adding-Linking-Constraints-(OptiEdges)-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-Linking-Constraints-(OptiEdges)" title="Permalink"></a></h2><p>Linking constraints (<a href="#Plasmo.LinkConstraint"><code>LinkConstraint</code></a>s) are linear constraints that couple variables across different optinodes.  The simplest way to create a linking constraint is to use the <code>@linkconstraint</code> macro.  This macro accepts the same input as the JuMP <code>@constraint</code> macro and creates linear constraints over multiple nodes within the same optigraph.</p><pre><code class="language-julia-repl">julia&gt; @linkconstraint(graph1, n1[:x] + nodes[2][:x] + nodes[3][:x] == 3)
LinkConstraintRef(1, OptiEdge w/ 1 Constraint(s))</code></pre><p>We can also plot the graph structure of <code>graph1</code> (see <a href="../plotting/#Plotting">Plotting</a>) using both a graph and matrix layouts.</p><pre><code class="language-julia-repl">julia&gt; using Plots; pyplot();
[ Info: Installing matplotlib via the Conda matplotlib package...
[ Info: Running `conda install -q -y matplotlib` in root environment
Collecting package metadata (current_repodata.json): ...working... done
Solving environment: ...working... done

## Package Plan ##

  environment location: /home/travis/.julia/conda/3

  added / updated specs:
    - matplotlib


The following packages will be downloaded:

    package                    |            build
    ---------------------------|-----------------
    cycler-0.10.0              |           py38_0          14 KB
    dbus-1.13.16               |       hb2f20db_0         501 KB
    expat-2.2.9                |       he6710b0_2         156 KB
    fontconfig-2.13.0          |       h9420a91_0         227 KB
    freetype-2.10.2            |       h5ab3b9f_0         608 KB
    glib-2.65.0                |       h3eb4bd4_0         2.9 MB
    gst-plugins-base-1.14.0    |       hbbd80ab_1         4.8 MB
    gstreamer-1.14.0           |       hb31296c_0         3.1 MB
    icu-58.2                   |       he6710b0_3        10.5 MB
    jpeg-9b                    |       h024ee3a_2         214 KB
    kiwisolver-1.2.0           |   py38hfd86e86_0          84 KB
    lcms2-2.11                 |       h396b838_0         307 KB
    libpng-1.6.37              |       hbc83047_0         278 KB
    libtiff-4.1.0              |       h2733197_1         449 KB
    libuuid-1.0.3              |       h1bed415_2          15 KB
    libxcb-1.14                |       h7b6447c_0         505 KB
    libxml2-2.9.10             |       he19cac6_1         1.2 MB
    lz4-c-1.9.2                |       he6710b0_1         190 KB
    matplotlib-3.3.1           |                0          24 KB
    matplotlib-base-3.3.1      |   py38h817c723_0         5.1 MB
    olefile-0.46               |             py_0          33 KB
    pcre-8.44                  |       he6710b0_0         212 KB
    pillow-7.2.0               |   py38hb39fc2d_0         617 KB
    pyparsing-2.4.7            |             py_0          65 KB
    pyqt-5.9.2                 |   py38h05f1152_4         4.5 MB
    python-dateutil-2.8.1      |             py_0         215 KB
    qt-5.9.7                   |       h5867ecd_1        68.5 MB
    sip-4.19.13                |   py38he6710b0_0         277 KB
    tornado-6.0.4              |   py38h7b6447c_1         603 KB
    zstd-1.4.5                 |       h9ceee32_0         619 KB
    ------------------------------------------------------------
                                           Total:       106.6 MB

The following NEW packages will be INSTALLED:

  cycler             pkgs/main/linux-64::cycler-0.10.0-py38_0
  dbus               pkgs/main/linux-64::dbus-1.13.16-hb2f20db_0
  expat              pkgs/main/linux-64::expat-2.2.9-he6710b0_2
  fontconfig         pkgs/main/linux-64::fontconfig-2.13.0-h9420a91_0
  freetype           pkgs/main/linux-64::freetype-2.10.2-h5ab3b9f_0
  glib               pkgs/main/linux-64::glib-2.65.0-h3eb4bd4_0
  gst-plugins-base   pkgs/main/linux-64::gst-plugins-base-1.14.0-hbbd80ab_1
  gstreamer          pkgs/main/linux-64::gstreamer-1.14.0-hb31296c_0
  icu                pkgs/main/linux-64::icu-58.2-he6710b0_3
  jpeg               pkgs/main/linux-64::jpeg-9b-h024ee3a_2
  kiwisolver         pkgs/main/linux-64::kiwisolver-1.2.0-py38hfd86e86_0
  lcms2              pkgs/main/linux-64::lcms2-2.11-h396b838_0
  libpng             pkgs/main/linux-64::libpng-1.6.37-hbc83047_0
  libtiff            pkgs/main/linux-64::libtiff-4.1.0-h2733197_1
  libuuid            pkgs/main/linux-64::libuuid-1.0.3-h1bed415_2
  libxcb             pkgs/main/linux-64::libxcb-1.14-h7b6447c_0
  libxml2            pkgs/main/linux-64::libxml2-2.9.10-he19cac6_1
  lz4-c              pkgs/main/linux-64::lz4-c-1.9.2-he6710b0_1
  matplotlib         pkgs/main/linux-64::matplotlib-3.3.1-0
  matplotlib-base    pkgs/main/linux-64::matplotlib-base-3.3.1-py38h817c723_0
  olefile            pkgs/main/noarch::olefile-0.46-py_0
  pcre               pkgs/main/linux-64::pcre-8.44-he6710b0_0
  pillow             pkgs/main/linux-64::pillow-7.2.0-py38hb39fc2d_0
  pyparsing          pkgs/main/noarch::pyparsing-2.4.7-py_0
  pyqt               pkgs/main/linux-64::pyqt-5.9.2-py38h05f1152_4
  python-dateutil    pkgs/main/noarch::python-dateutil-2.8.1-py_0
  qt                 pkgs/main/linux-64::qt-5.9.7-h5867ecd_1
  sip                pkgs/main/linux-64::sip-4.19.13-py38he6710b0_0
  tornado            pkgs/main/linux-64::tornado-6.0.4-py38h7b6447c_1
  zstd               pkgs/main/linux-64::zstd-1.4.5-h9ceee32_0


Preparing transaction: ...working... done
Verifying transaction: ...working... done
Executing transaction: ...working... done

julia&gt; plt_graph = Plots.plot(graph1,node_labels = true, markersize = 30,labelsize = 15, linewidth = 4,layout_options = Dict(:tol =&gt; 0.01,:iterations =&gt; 2),plt_options = Dict(:legend =&gt; false,:framestyle =&gt; :box,:grid =&gt; false,:size =&gt; (400,400),:axis =&gt; nothing));

julia&gt; Plots.savefig(plt_graph,&quot;graph1_layout.svg&quot;);

julia&gt; plt_matrix = Plots.spy(graph1,node_labels = true,markersize = 15);

julia&gt; Plots.savefig(plt_matrix,&quot;matrix1_layout.svg&quot;);</code></pre><img src="graph1_layout.svg" alt="graph1" width="400"/><img src="matrix1_layout.svg" alt="matrix1" width="400"/><h2 id="Hierarchical-Modeling"><a class="docs-heading-anchor" href="#Hierarchical-Modeling">Hierarchical Modeling</a><a id="Hierarchical-Modeling-1"></a><a class="docs-heading-anchor-permalink" href="#Hierarchical-Modeling" title="Permalink"></a></h2><p>A fundamental feature of using optigraphs is that it is possible to create subgraphs (i.e. sub-optigraphs) within an optigraph.  This enables a hierarchical style of modeling that retains its modular aspects. Subgraphs are defined using the <a href="#Plasmo.add_subgraph!"><code>add_subgraph!</code></a> function which embeds an optigraph as a subgraph within a higher level optigraph. This is demonstrated in the below snippets.  </p><p>First, we create two new optigraphs in the same fashion we did above.</p><pre><code class="language-julia-repl">julia&gt; graph2 = OptiGraph();

julia&gt; @optinode(graph2,nodes2[1:3]);

julia&gt;  for node in getnodes(graph2)
            @variable(node, x &gt;= 0)
            @variable(node, y &gt;= 2)
            @constraint(node,x + y &gt;= 5)
            @objective(node, Min, y)
        end

julia&gt; @linkconstraint(graph2, nodes2[1][:x] + nodes2[2][:x] + nodes2[3][:x] == 5);

julia&gt; graph3 = OptiGraph();

julia&gt; @optinode(graph3,nodes3[1:3]);

julia&gt;  for node in getnodes(graph3)
            @variable(node, x &gt;= 0)
            @variable(node, y &gt;= 2)
            @constraint(node,x + y &gt;= 5)
            @objective(node, Min, y)
        end

julia&gt; @linkconstraint(graph3, nodes3[1][:x] + nodes3[2][:x] + nodes3[3][:x] == 7);</code></pre><p>Now we have three optigraphs (<code>graph1</code>,<code>graph2</code>, and <code>graph3</code>), each with their own local optinodes and linking constraints (which induce optiedges).   These optigraphs can be embedded into a higher level optigraph with the following snippet:</p><pre><code class="language-julia-repl">julia&gt; graph0 = OptiGraph()
OptiGraph:
local nodes: 0, total nodes: 0
local link constraints: 0, total link constraints 0
local subgraphs: 0, total subgraphs 0

julia&gt; add_subgraph!(graph0,graph1)
OptiGraph:
local nodes: 0, total nodes: 3
local link constraints: 0, total link constraints 1
local subgraphs: 1, total subgraphs 1

julia&gt; add_subgraph!(graph0,graph2)
OptiGraph:
local nodes: 0, total nodes: 6
local link constraints: 0, total link constraints 2
local subgraphs: 2, total subgraphs 2

julia&gt; add_subgraph!(graph0,graph3)
OptiGraph:
local nodes: 0, total nodes: 9
local link constraints: 0, total link constraints 3
local subgraphs: 3, total subgraphs 3</code></pre><p>Here, we see the distinction between local and global (total) elements. For instance, after we add all three subgraphs the higher level <code>graph0</code>, we see that <code>graph0</code> contains 0 local optinodes, but contains 9 total optinodes which are elements of its subgraphs. This hierarchical distinction is also made for linking constraints (i.e. optiedges), as well as subgraphs.  With this hierarhical style of modeling, subgraphs can be nested recursively such that an optigraph might contain local subgraphs, and the highest level optigraph contains all of the subgraphs.</p><p>A key benefit of this hierarchical approach is that linking constraints can be expressed both locally and globally.  For instance, we can now add a linking constraint to <code>graph0</code> that connects optinodes in its subgraphs like following:</p><pre><code class="language-julia-repl">julia&gt; @linkconstraint(graph0,nodes[3][:x] + nodes2[2][:x] + nodes3[1][:x] == 10)
LinkConstraintRef(1, OptiEdge w/ 1 Constraint(s))

julia&gt; println(graph0)
OptiGraph:
local nodes: 0, total nodes: 9
local link constraints: 1, total link constraints 4
local subgraphs: 3, total subgraphs 3</code></pre><p>We now observe that <code>graph0</code> contains 1 local linking constraint, and 4 total linking constraints (by including its subgraphs). Put another way, the local linking constraint in <code>graph0</code> is a global constraint that connects each of its subgraphs. This hierarchical style of modeling facilitates the construction of optimization problems that include diverse model components.  For instance, a power system could be modeled separately from a natural gas system and they could be coupled in a higher level combined optigraph.  The hierarchical structure also enables the use of distributed optimization solvers which we discuss more in the <a href="../solvers/#Solvers">Solvers</a> section.</p><p>We can lastly plot the hierarchical optigraph and see the nested subgraph structure.</p><pre><code class="language-julia-repl">julia&gt; using Plots

julia&gt; for (i,node) in enumerate(all_nodes(graph0))
           node.label = &quot;n$i&quot;
       end

julia&gt; plt_graph0 = Plots.plot(graph0,node_labels = true,markersize = 60,labelsize = 30,linewidth = 4,subgraph_colors = true,
       layout_options = Dict(:tol =&gt; 0.001,:C =&gt; 2, :K =&gt; 4, :iterations =&gt; 5));

julia&gt; Plots.savefig(plt_graph0,&quot;graph0_layout.svg&quot;);

julia&gt; plt_matrix0 = Plots.spy(graph0,node_labels = true,subgraph_colors = true,markersize = 16);

julia&gt; Plots.savefig(plt_matrix0,&quot;matrix0_layout.svg&quot;);</code></pre><img src="graph0_layout.svg" alt="graph0" width="400"/><img src="matrix0_layout.svg" alt="matrix0" width="400"/><h2 id="Query-OptiGraph-Attributes"><a class="docs-heading-anchor" href="#Query-OptiGraph-Attributes">Query OptiGraph Attributes</a><a id="Query-OptiGraph-Attributes-1"></a><a class="docs-heading-anchor-permalink" href="#Query-OptiGraph-Attributes" title="Permalink"></a></h2><p>There are a few primary function which can be used to query optigraph attributes. <code>getnodes</code> can be used to retrieve an array of the local optinodes in an optigraph, whereas <code>all_nodes</code> will recursively retrieve all of the optinodes in an optigraph, including the nodes in its subgraphs.</p><pre><code class="language-julia-repl">julia&gt; getnodes(graph1)
3-element Array{OptiNode,1}:
 OptiNode w/ 2 Variable(s)
 OptiNode w/ 2 Variable(s)
 OptiNode w/ 2 Variable(s)

julia&gt; getnodes(graph0)
0-element Array{OptiNode,1}

julia&gt; all_nodes(graph0)
9-element Array{OptiNode,1}:
 OptiNode w/ 2 Variable(s)
 OptiNode w/ 2 Variable(s)
 OptiNode w/ 2 Variable(s)
 OptiNode w/ 2 Variable(s)
 OptiNode w/ 2 Variable(s)
 OptiNode w/ 2 Variable(s)
 OptiNode w/ 2 Variable(s)
 OptiNode w/ 2 Variable(s)
 OptiNode w/ 2 Variable(s)
</code></pre><p>It is possible to query for optiedges, linking constraints, and subgraphs in the same way. We can query optiedges:</p><pre><code class="language-julia-repl">julia&gt; getedges(graph1)
1-element Array{OptiEdge,1}:
 OptiEdge w/ 1 Constraint(s)

julia&gt; getedges(graph0)
1-element Array{OptiEdge,1}:
 OptiEdge w/ 1 Constraint(s)

julia&gt; all_edges(graph0)
4-element Array{OptiEdge,1}:
 OptiEdge w/ 1 Constraint(s)
 OptiEdge w/ 1 Constraint(s)
 OptiEdge w/ 1 Constraint(s)
 OptiEdge w/ 1 Constraint(s)</code></pre><p>query linking constraints:</p><pre><code class="language-julia-repl">julia&gt; getlinkconstraints(graph1)
1-element Array{LinkConstraint,1}:
 LinkConstraint: x + x + x, MathOptInterface.EqualTo{Float64}(3.0)

julia&gt; getlinkconstraints(graph0)
1-element Array{LinkConstraint,1}:
 LinkConstraint: x + x + x, MathOptInterface.EqualTo{Float64}(10.0)

julia&gt; all_linkconstraints(graph0)
4-element Array{LinkConstraint,1}:
 LinkConstraint: x + x + x, MathOptInterface.EqualTo{Float64}(3.0)
 LinkConstraint: x + x + x, MathOptInterface.EqualTo{Float64}(5.0)
 LinkConstraint: x + x + x, MathOptInterface.EqualTo{Float64}(7.0)
 LinkConstraint: x + x + x, MathOptInterface.EqualTo{Float64}(10.0)</code></pre><p>and query subgraphs:</p><pre><code class="language-julia-repl">julia&gt; getsubgraphs(graph0)
3-element Array{AbstractOptiGraph,1}:
 OptiGraph:
local nodes: 3, total nodes: 3
local link constraints: 1, total link constraints 1
local subgraphs: 0, total subgraphs 0

 OptiGraph:
local nodes: 3, total nodes: 3
local link constraints: 1, total link constraints 1
local subgraphs: 0, total subgraphs 0

 OptiGraph:
local nodes: 3, total nodes: 3
local link constraints: 1, total link constraints 1
local subgraphs: 0, total subgraphs 0</code></pre><h2 id="Methods"><a class="docs-heading-anchor" href="#Methods">Methods</a><a id="Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Methods" title="Permalink"></a></h2><p>Modeling with an <code>OptiGraph</code> encompasses various useful methods.  It is important to note that both the <code>OptiGraph</code> and the <code>OptiNode</code> are extensions of the <code>JuMP.AbstractModel</code> and can use many of the same methods. We refer to the <a href="https://jump.dev/JuMP.jl/stable/">JuMP Documentation</a> which describes most methods. Some select functions are also listed here.</p><h3 id="OptiGraph-Functions"><a class="docs-heading-anchor" href="#OptiGraph-Functions">OptiGraph Functions</a><a id="OptiGraph-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#OptiGraph-Functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Plasmo.OptiGraph" href="#Plasmo.OptiGraph"><code>Plasmo.OptiGraph</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OptiGraph()</code></pre><p>Create an empty OptiGraph. An OptiGraph extends JuMP.AbstractModel and supports many JuMP.Model functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jalving/Plasmo.jl/blob/b7b71cf97879d25c04c371dc67dcc6478708f605/src/optigraph.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plasmo.@optinode" href="#Plasmo.@optinode"><code>Plasmo.@optinode</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@optinode(optigraph, expr...)</code></pre><p>Add a new optinode to <code>optigraph</code>. The expression <code>expr</code> can either be</p><ul><li>of the form <code>varname</code> creating a single optinode with the variable name <code>varname</code></li><li>of the form <code>varname[...]</code> or <code>[...]</code> creating a container of optinodes using JuMP Containers</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jalving/Plasmo.jl/blob/b7b71cf97879d25c04c371dc67dcc6478708f605/src/macros.jl#L3-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plasmo.OptiNode" href="#Plasmo.OptiNode"><code>Plasmo.OptiNode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OptiNode()</code></pre><p>Creates an empty OptiNode.  Does not add it to a graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jalving/Plasmo.jl/blob/b7b71cf97879d25c04c371dc67dcc6478708f605/src/optinode.jl#L27-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plasmo.add_node!" href="#Plasmo.add_node!"><code>Plasmo.add_node!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_node!(graph::OptiGraph)</code></pre><p>Create a new <code>OptiNode</code> and add it to <code>graph</code>. Returns the added optinode.</p><pre><code class="language-none">add_node!(graph::OptiGraph,m::JuMP.Model)</code></pre><p>Add a new optinode to <code>graph</code> and set its model to the <code>JuMP.Model</code> <code>m</code>.</p><pre><code class="language-none">add_node!(graph::OptiGraph,optinode::OptiNode)</code></pre><p>Add the existing <code>optinode</code> (Created with <code>OptiNode()</code>) to <code>graph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jalving/Plasmo.jl/blob/b7b71cf97879d25c04c371dc67dcc6478708f605/src/optigraph.jl#L93-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plasmo.getnode" href="#Plasmo.getnode"><code>Plasmo.getnode</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getnode(graph::OptiGraph) = graph.optinodes</code></pre><p>Retrieve the local optinode in <code>graph</code> at <code>index</code>. This does not look up nodes that could be in subgraphs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jalving/Plasmo.jl/blob/b7b71cf97879d25c04c371dc67dcc6478708f605/src/optigraph.jl#L134-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plasmo.getnodes" href="#Plasmo.getnodes"><code>Plasmo.getnodes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getnodes(graph::OptiGraph) = graph.optinodes</code></pre><p>Retrieve the optinodes in <code>graph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jalving/Plasmo.jl/blob/b7b71cf97879d25c04c371dc67dcc6478708f605/src/optigraph.jl#L127-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plasmo.find_node" href="#Plasmo.find_node"><code>Plasmo.find_node</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">find_node(graph::OptiGraph,index::Int64)</code></pre><p>Find the optinode in <code>graph</code> at <code>index</code>. This traverses all of the nodes in the subgraphs of <code>graph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jalving/Plasmo.jl/blob/b7b71cf97879d25c04c371dc67dcc6478708f605/src/optigraph.jl#L154-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plasmo.is_node_variable" href="#Plasmo.is_node_variable"><code>Plasmo.is_node_variable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_node_variable(node::OptiNode,var::JuMP.AbstractVariableRef)</code></pre><p>Checks whether the variable <code>var</code> belongs to the optinode <code>node</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jalving/Plasmo.jl/blob/b7b71cf97879d25c04c371dc67dcc6478708f605/src/optinode.jl#L120-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{OptiGraph,OptiNode}" href="#Base.getindex-Tuple{OptiGraph,OptiNode}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.getindex(graph::OptiGraph,node::OptiNode)</code></pre><p>Retrieve the index of the optinode <code>node</code> in <code>graph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jalving/Plasmo.jl/blob/b7b71cf97879d25c04c371dc67dcc6478708f605/src/optigraph.jl#L164-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{OptiGraph,OptiEdge}" href="#Base.getindex-Tuple{OptiGraph,OptiEdge}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.getindex(graph::OptiGraph,optiedge::OptiEdge)</code></pre><p>Retrieve the index of the <code>optiedge</code> in <code>graph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jalving/Plasmo.jl/blob/b7b71cf97879d25c04c371dc67dcc6478708f605/src/optigraph.jl#L233-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plasmo.nodevalue" href="#Plasmo.nodevalue"><code>Plasmo.nodevalue</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nodevalue(var::JuMP.VariableRef)</code></pre><p>Get the current value of <code>var</code></p><pre><code class="language-none">nodevalue(expr::JuMP.GenericAffExpr)</code></pre><p>Get the current value of <code>expr</code> which is <code>JuMP.GenericAffExpr</code></p><pre><code class="language-none">nodevalue(expr::JuMP.GenericQuadExpr)</code></pre><p>Get the current value of <code>expr</code> which is a <code>JuMP.GenericQuadExpr</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jalving/Plasmo.jl/blob/b7b71cf97879d25c04c371dc67dcc6478708f605/src/optinode.jl#L70-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plasmo.all_nodes" href="#Plasmo.all_nodes"><code>Plasmo.all_nodes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">all_nodes(graph::OptiGraph)</code></pre><p>Recursively collect nodes in a optigraph from each of its subgraphs</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jalving/Plasmo.jl/blob/b7b71cf97879d25c04c371dc67dcc6478708f605/src/optigraph.jl#L141-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plasmo.set_model" href="#Plasmo.set_model"><code>Plasmo.set_model</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">set_model(node::OptiNode,m::AbstractModel)</code></pre><p>Set the model on a node.  This will delete any link-constraints the node is currently part of</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jalving/Plasmo.jl/blob/b7b71cf97879d25c04c371dc67dcc6478708f605/src/optinode.jl#L104-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plasmo.@NLnodeconstraint" href="#Plasmo.@NLnodeconstraint"><code>Plasmo.@NLnodeconstraint</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@NLnodeconstraint(node,args...)</code></pre><p>Add a nonlinear constraint to an optinode.  Wraps JuMP.@NLconstraint.  This method will deprecate once optinodes extend nonlinear JuMP functionality.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jalving/Plasmo.jl/blob/b7b71cf97879d25c04c371dc67dcc6478708f605/src/macros.jl#L112-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plasmo.@linkconstraint" href="#Plasmo.@linkconstraint"><code>Plasmo.@linkconstraint</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@linkconstraint(graph::OptiGraph, expr)</code></pre><p>Add a linking constraint described by the expression <code>expr</code>.</p><pre><code class="language-none">@linkconstraint(graph::OptiGraph, ref[i=..., j=..., ...], expr)</code></pre><p>Add a group of linking  constraints described by the expression <code>expr</code> parametrized by <code>i</code>, <code>j</code>, ...</p><p>The @linkconstraint macro works the same way as the <code>JuMP.@constraint</code> macro.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jalving/Plasmo.jl/blob/b7b71cf97879d25c04c371dc67dcc6478708f605/src/macros.jl#L67-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plasmo.OptiEdge" href="#Plasmo.OptiEdge"><code>Plasmo.OptiEdge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OptiEdge</code></pre><p>The <code>OptiEdge</code> type.  Typically created from <a href="#Plasmo.@linkconstraint"><code>@linkconstraint</code></a>.  Contains the set of its supporting optionodes, as well as references to its underlying linking constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jalving/Plasmo.jl/blob/b7b71cf97879d25c04c371dc67dcc6478708f605/src/optiedge.jl#L29-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plasmo.getedge" href="#Plasmo.getedge"><code>Plasmo.getedge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getedge(graph::OptiGraph,index::Int64)</code></pre><p>Retrieve the local optiedge in <code>graph</code> at <code>index</code></p><pre><code class="language-none">getedge(graph::OptiGraph,nodes::OrderedSet{OptiNode})</code></pre><p>Retrieve the optiedge in <code>graph</code> that connects the optinodes in the OrderedSet of <code>nodes</code>.</p><pre><code class="language-none">getedge(graph::OptiGraph,nodes::OptiNode...)</code></pre><p>Retrieve the optiedge in <code>graph</code> that connects <code>nodes</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jalving/Plasmo.jl/blob/b7b71cf97879d25c04c371dc67dcc6478708f605/src/optigraph.jl#L200-L212">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plasmo.getedges" href="#Plasmo.getedges"><code>Plasmo.getedges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getedges(graph::OptiGraph) = graph.optiedges</code></pre><p>Retrieve the local optiedges in <code>graph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jalving/Plasmo.jl/blob/b7b71cf97879d25c04c371dc67dcc6478708f605/src/optigraph.jl#L193-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plasmo.all_edges" href="#Plasmo.all_edges"><code>Plasmo.all_edges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">all_edges(graph::OptiGraph)</code></pre><p>Retrieve all optiedges in <code>graph</code>, includes edges in subgraphs of <code>graph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jalving/Plasmo.jl/blob/b7b71cf97879d25c04c371dc67dcc6478708f605/src/optigraph.jl#L220-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plasmo.LinkConstraint" href="#Plasmo.LinkConstraint"><code>Plasmo.LinkConstraint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LinkConstraint{F &lt;: JuMP.AbstractJuMPScalar,S &lt;: MOI.AbstractScalarSet} &lt;: AbstractLinkConstraint</code></pre><p>Type inherits JuMP.AbstractConstraint.  Contains a func and set used to describe coupling between optinodes.</p><pre><code class="language-none">LinkConstraint(con::JuMP.ScalarConstraint)</code></pre><p>Creates a linking constraint from a JuMP.ScalarConstraint.</p><pre><code class="language-none">LinkConstraint(ref::LinkConstraintRef)</code></pre><p>Retrieves a linking constraint from a LinkConstraintRef.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jalving/Plasmo.jl/blob/b7b71cf97879d25c04c371dc67dcc6478708f605/src/optiedge.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plasmo.getlinkconstraints" href="#Plasmo.getlinkconstraints"><code>Plasmo.getlinkconstraints</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getlinkconstraints(graph::OptiGraph)::Vector{LinkConstraint}</code></pre><p>Retrieve the local linking constraints in <code>graph</code>. Returns a vector of the linking constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jalving/Plasmo.jl/blob/b7b71cf97879d25c04c371dc67dcc6478708f605/src/optigraph.jl#L269-L273">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plasmo.all_linkconstraints" href="#Plasmo.all_linkconstraints"><code>Plasmo.all_linkconstraints</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">all_linkconstraints(graph::OptiGraph)::Vector{LinkConstraint}</code></pre><p>Retrieve all of the linking constraints in <code>graph</code>, including linking constraints in its subgraphs. Returns a vector of the linking constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jalving/Plasmo.jl/blob/b7b71cf97879d25c04c371dc67dcc6478708f605/src/optigraph.jl#L282-L286">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plasmo.add_subgraph!" href="#Plasmo.add_subgraph!"><code>Plasmo.add_subgraph!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_subgraph!(graph::OptiGraph,subgraph::OptiGraph)</code></pre><p>Add the sub-optigraph <code>subgraph</code> to the higher level optigraph <code>graph</code>. Returns the original <code>graph</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jalving/Plasmo.jl/blob/b7b71cf97879d25c04c371dc67dcc6478708f605/src/optigraph.jl#L60-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plasmo.getsubgraphs" href="#Plasmo.getsubgraphs"><code>Plasmo.getsubgraphs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getsubgraphs(optigraph::OptiGraph)::Vector{OptiGraph}</code></pre><p>Retrieve the local subgraphs of <code>optigraph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jalving/Plasmo.jl/blob/b7b71cf97879d25c04c371dc67dcc6478708f605/src/optigraph.jl#L70-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plasmo.all_subgraphs" href="#Plasmo.all_subgraphs"><code>Plasmo.all_subgraphs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">all_subgraphs(optigraph::OptiGraph)::Vector{OptiGraph}</code></pre><p>Retrieve all of the contained subgraphs of <code>optigraph</code>, including nested subgraphs. The order of the subgraphs in the returned vector starts with the local subgraphs in <code>optigraph</code> and then appends the nested subgraphs for each local subgraph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jalving/Plasmo.jl/blob/b7b71cf97879d25c04c371dc67dcc6478708f605/src/optigraph.jl#L77-L82">source</a></section></article><h3 id="Extended-JuMP-Functions"><a class="docs-heading-anchor" href="#Extended-JuMP-Functions">Extended JuMP Functions</a><a id="Extended-JuMP-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Extended-JuMP-Functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="JuMP.all_variables-Tuple{OptiNode}" href="#JuMP.all_variables-Tuple{OptiNode}"><code>JuMP.all_variables</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.all_variables(node::OptiNode)::Vector{JuMP.VariableRef}</code></pre><p>Retrieve all of the variables on the optinode <code>node</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jalving/Plasmo.jl/blob/b7b71cf97879d25c04c371dc67dcc6478708f605/src/optinode.jl#L60-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_optimizer-Tuple{OptiGraph,Any}" href="#JuMP.set_optimizer-Tuple{OptiGraph,Any}"><code>JuMP.set_optimizer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.set_optimizer(graph::OptiGraph,optimizer::Any)</code></pre><p>Set an optimizer for the optigraph <code>graph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jalving/Plasmo.jl/blob/b7b71cf97879d25c04c371dc67dcc6478708f605/src/optigraph.jl#L557-L561">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.objective_function-Tuple{OptiGraph}" href="#JuMP.objective_function-Tuple{OptiGraph}"><code>JuMP.objective_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.objective_function(graph::OptiGraph)</code></pre><p>Retrieve the current graph objective function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jalving/Plasmo.jl/blob/b7b71cf97879d25c04c371dc67dcc6478708f605/src/optigraph.jl#L334-L338">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.value-Tuple{OptiNode,VariableRef}" href="#JuMP.value-Tuple{OptiNode,VariableRef}"><code>JuMP.value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.value(node::OptiNode,vref::VariableRef)</code></pre><p>Get the variable value of <code>vref</code> on the optinode <code>node</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jalving/Plasmo.jl/blob/b7b71cf97879d25c04c371dc67dcc6478708f605/src/optinode.jl#L51-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.num_variables-Tuple{OptiGraph}" href="#JuMP.num_variables-Tuple{OptiGraph}"><code>JuMP.num_variables</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.num_variables(graph::OptiGraph)</code></pre><p>Retrieve the number of local node variables in <code>graph</code>. Does not include variables in subgraphs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jalving/Plasmo.jl/blob/b7b71cf97879d25c04c371dc67dcc6478708f605/src/optigraph.jl#L310-L314">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.num_constraints-Tuple{OptiGraph}" href="#JuMP.num_constraints-Tuple{OptiGraph}"><code>JuMP.num_constraints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.num_constraints(graph::OptiGraph)</code></pre><p>Retrieve the number of local node constraints in <code>graph</code>. Does not include constraints in subgraphs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jalving/Plasmo.jl/blob/b7b71cf97879d25c04c371dc67dcc6478708f605/src/optigraph.jl#L320-L324">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Introduction</a><a class="docs-footer-nextpage" href="../partitioning/">Partitioning and Graph Operations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 11 September 2020 19:10">Friday 11 September 2020</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
