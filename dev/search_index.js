var documenterSearchIndex = {"docs":
[{"location":"documentation/solvers/#Solvers","page":"Solvers","title":"Solvers","text":"","category":"section"},{"location":"documentation/solvers/","page":"Solvers","title":"Solvers","text":"Plasmo.jl supports JuMP/MOI enabled solvers, as well as the PIPS-NLP parallel optimization solver.","category":"page"},{"location":"documentation/solvers/#JuMP/MOI-Solvers","page":"Solvers","title":"JuMP/MOI Solvers","text":"","category":"section"},{"location":"documentation/solvers/","page":"Solvers","title":"Solvers","text":"Plasmo.jl can use JuMP/MOI solvers by means of its aggregate function.     The example below solves an optigraph using Ipopt, where underneath, optimize! produces a single OptiNode (which encapsulates a JuMP.Model), solves the optinode, and populates the solution of the optigraph with the result.","category":"page"},{"location":"documentation/solvers/","page":"Solvers","title":"Solvers","text":"using Plasmo\nusing Ipopt\n\ngraph = OptiGraph()\n\n@optinode(graph,n1)\n@optinode(graph,n2)\n\n@variable(n1,0 <= x <= 2)\n@variable(n1,0 <= y <= 3)\n@constraint(n1,x+y <= 4)\n@objective(n1,Min,x)\n\n@variable(n2,x)\n@NLnodeconstraint(n2,exp(x) >= 2)\n\n@linkconstraint(graph,n1[:x] == n2[:x])\n\nipopt = Ipopt.Optimizer\noptimize!(graph,ipopt)","category":"page"},{"location":"documentation/solvers/","page":"Solvers","title":"Solvers","text":"CurrentModule = Plasmo\nDocTestSetup = quote\n    using Plasmo\n    using Ipopt\n\n    graph = OptiGraph()\n\n    @optinode(graph,n1)\n    @optinode(graph,n2)\n\n    @variable(n1,0 <= x <= 2)\n    @variable(n1,0 <= y <= 3)\n    @constraint(n1,x+y <= 4)\n    @objective(n1,Min,x)\n\n    @variable(n2,x)\n    @NLnodeconstraint(n2,exp(x) >= 2)\n\n    @linkconstraint(graph,n1[:x] == n2[:x])\n\n    ipopt = Ipopt.Optimizer\n    optimize!(graph,ipopt)\nend","category":"page"},{"location":"documentation/solvers/","page":"Solvers","title":"Solvers","text":"A result specific to an optinode can be accessed using the nodevalue function.  Here we see that the value of x on  optinodes n1 and n2 can be queried (and are consistent with the linking constraint).","category":"page"},{"location":"documentation/solvers/","page":"Solvers","title":"Solvers","text":"julia> println(\"n1[:x]= \",round(nodevalue(n1[:x]),digits = 5))\nn1[:x]= 0.69315\n\njulia> println(\"n2[:x]= \",round(nodevalue(n2[:x]),digits = 5))\nn2[:x]= 0.69315","category":"page"},{"location":"documentation/solvers/#PipsSolver","page":"Solvers","title":"PipsSolver","text":"","category":"section"},{"location":"documentation/solvers/","page":"Solvers","title":"Solvers","text":"The PipsSolver interface can be used to solve structured nonlinear optimization problems with PIPS-NLP. To do so, we use the MPClusterManagers package and Julia's Distributed module to distribute an optigraph among worker CPUs.  We then execute PIPS-NLP using MPI using @mpi_do (available from MPIClusterManagers) which runs MPI on each worker. The below example shows how this is done for a simple optigraph with two optinodes and two MPI ranks.","category":"page"},{"location":"documentation/solvers/","page":"Solvers","title":"Solvers","text":"using MPIClusterManagers\nusing Distributed\n\n# specify 2 MPI workers\nmanager=MPIManager(np=2)\n\n# uses Distributed to add processors to a manager\naddprocs(manager)\n\n@everywhere using Plasmo\n@everywhere using PipsSolver\n\njulia_workers = collect(values(manager.mpi2j))\n\ngraph = OptiGraph()\n\n@optinode(graph,n1)\n@optinode(graph,n2)\n\n@variable(n1,0 <= x <= 2)\n@variable(n1,0 <= y <= 3)\n@variable(n1, z >= 0)\n@constraint(n1,x+y+z >= 4)\n@objective(n1,Min,y)\n\n@variable(n2,x)\n@NLnodeconstraint(n2,ref,exp(x) >= 2)\n@variable(n2,z >= 0)\n@constraint(n2,z + x >= 4)\n@objective(n2,Min,x)\n\n@linkconstraint(graph,n1[:x] == n2[:x])\n\n#Distribute the graph to workers.  #create the variable pipsgraph on each worker\nremote_references = PipsSolver.distribute(graph,julia_workers,remote_name = :pipsgraph)\n\n#Execute MPI\n@mpi_do manager begin\n    using MPI\n    PipsSolver.pipsnlp_solve(pipsgraph)\nend","category":"page"},{"location":"documentation/solvers/#SchwarzSolver","page":"Solvers","title":"SchwarzSolver","text":"","category":"section"},{"location":"documentation/solvers/","page":"Solvers","title":"Solvers","text":"Documentation Coming Soon","category":"page"},{"location":"documentation/modeling/#Modeling","page":"Modeling","title":"Modeling","text":"","category":"section"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"In Plasmo.jl, the primary modeling object is called an OptiGraph. The OptiGraph adheres to a graph-based style of modeling that uses nodes and edges to create optimization problems. This graph-based style permits modular model development and makes it possible to capture and represent complex optimization problem structures. An OptiGraph is composed of OptiNodes which represent individual optimization problems that are connected by OptiEdges which encapsulate LinkConstraints (i.e. linking constraints that couple optinodes). A key idea behind Plasmo's' graph-based approach is that it works at a high level of abstraction and uses modular principles and hierarchical modeling to express complex optimization problems. The optimization models created with an optigraph can be used to reveal inherent structures that lend themselves to graph processing tasks such as partitioning.","category":"page"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"The OptiGraph ultimately describes the following mathematical representation of an optimization problem:","category":"page"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"beginaligned\n    min_x_n_n in mathcalN(mathcalG)  quad sum_n in mathcalN(mathcalG) f_n(x_n) quad  (textrmObjective) \n    textrmst  quad x_n in mathcalX_n      quad n in mathcalN(mathcalG) quad  (textrmNode Constraints)\n     quad g_e(x_n_n in mathcalN(e)) = 0  quad e in mathcalE(mathcalG) (textrmLink Constraints)\nendaligned","category":"page"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"In this formulation, mathcalG represents the optigraph, x_n_n in mathcalN(mathcalG) describes a collection of decision variables over the set of nodes (optinodes) mathcalN(mathcalG), and x_n is the set of decision variables on node n. The objective function for the optigraph mathcalG is given by a linear combination of objective functions on each optinode f_n(x_n). The second equation represents constraints on each optinode mathcalN(mathcalG), and the third equation represents the collection of linking constraints associated with optiedges mathcalE(mathcalG). The constraints of an optinode n are represented by the set mathcalX_n while the linking constraints that correspond to an edge e are represented by the vector function g_e(x_n_n in mathcalN(e)).","category":"page"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"From an implementation standpoint, an OptiGraph contains OptiNode and OptiEdge objects and extends much of the modeling functionality and syntax from JuMP. The OptiNode object encapsulates a Model object from JuMP, and the OptiEdge object encapsulates the linking constraints that define coupling between optinodes.","category":"page"},{"location":"documentation/modeling/#Creating-an-OptiGraph","page":"Modeling","title":"Creating an OptiGraph","text":"","category":"section"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"An OptiGraph does not require any arguments to construct:","category":"page"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"CurrentModule = Plasmo\nDocTestSetup = quote\n    using Plasmo\nend","category":"page"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"julia> graph1 = OptiGraph()\nOptiGraph:\nlocal nodes: 0, total nodes: 0\nlocal link constraints: 0, total link constraints 0\nlocal subgraphs: 0, total subgraphs 0","category":"page"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"DocTestSetup = nothing","category":"page"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"An optigraph optimizer can also be specified using JuMP.set_optimizer where an optimizer can be any JuMP compatible solver or a custom developed Plasmo.jl solver (see the Solvers section).   For example, we could construct an optigraph that uses the Ipopt.Optimizer from the Ipopt package like following:","category":"page"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"julia> using Ipopt\n\njulia> set_optimizer(graph1,Ipopt.Optimizer)","category":"page"},{"location":"documentation/modeling/#Adding-OptiNodes","page":"Modeling","title":"Adding OptiNodes","text":"","category":"section"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"The most effective way to add optinodes to an optigraph is by using the @optinode macro.  The below piece of code adds the node n1 to the optigraph graph1.","category":"page"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"julia> @optinode(graph1,n1)\nOptiNode w/ 0 Variable(s)","category":"page"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"It is also possible to create sets of optinodes with a single call to @optinode like shown in the below code snippet. Here, we create two more optinodes which returns the reference nodes. This input produces a JuMP.DenseAxisArray which allows us to refer to each optinode using the produced index sets.  For example, nodes[2] and nodes[3] each return the corresponding optinode.","category":"page"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"julia> @optinode(graph1,nodes[2:3])\n1-dimensional DenseAxisArray{OptiNode,1,...} with index sets:\n    Dimension 1, 2:3\nAnd data, a 2-element Array{OptiNode,1}:\n OptiNode w/ 0 Variable(s)\n OptiNode w/ 0 Variable(s)\n\njulia> nodes[2]\nOptiNode w/ 0 Variable(s)\n\njulia> nodes[3]\nOptiNode w/ 0 Variable(s)","category":"page"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"Each optinode can have its underlying model constructed in a modular way.  Here we loop through each optinode in graph1 using getnodes and construct its underlying model by adding variables, a constraint, and objective function.","category":"page"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"julia>  for node in getnodes(graph1)\n            @variable(node,x >= 0)\n            @variable(node, y >= 2)\n            @constraint(node,x + y >= 3)\n            @objective(node, Min, y)\n        end","category":"page"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"note: Note\nThe OptiNode extends JuMP.AbstractModel and supports most of the same JuMP macros. However, extending nonlinear functionality in JuMP is not yet supported, and so  one must use @NLnodeconstraint as opposed @NLconstraint to create nonlinear constraints on an optinode.","category":"page"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"Variables within an optinode can be accessed directly by indexing the associated symbol.  This enclosed variable space is useful for referencing variables on different optinodes when creating linking constraints or optigraph objective functions.","category":"page"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"julia> n1[:x]\nx\n\njulia> nodes[2][:y]\ny","category":"page"},{"location":"documentation/modeling/#Adding-Linking-Constraints-(OptiEdges)","page":"Modeling","title":"Adding Linking Constraints (OptiEdges)","text":"","category":"section"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"Linking constraints (LinkConstraints) are linear constraints that couple variables across different optinodes.  The simplest way to create a linking constraint is to use the @linkconstraint macro.  This macro accepts the same input as the JuMP @constraint macro and creates linear constraints over multiple nodes within the same optigraph.","category":"page"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"julia> @linkconstraint(graph1, n1[:x] + nodes[2][:x] + nodes[3][:x] == 3)\nLinkConstraintRef(1, OptiEdge w/ 1 Constraint(s))","category":"page"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"We can also plot the graph structure of graph1 (see Plotting) using both a graph and matrix layouts.","category":"page"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"    using Plasmo\n    graph1 = OptiGraph()\n    @optinode(graph1,n1)\n    @optinode(graph1,nodes[2:3])\n\n    for node in getnodes(graph1)\n        @variable(node,x >= 0)\n        @variable(node, y >= 2)\n        @constraint(node,x + y >= 3)\n        @objective(node, Min, y)\n    end\n\n    @linkconstraint(graph1, n1[:x] + nodes[2][:x] + nodes[3][:x] == 3)","category":"page"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"using Plots;\n\nplt_graph = Plots.plot(graph1,node_labels = true, markersize = 30,labelsize = 15, linewidth = 4,layout_options = Dict(:tol => 0.01,:iterations => 2),plt_options = Dict(:legend => false,:framestyle => :box,:grid => false,:size => (400,400),:axis => nothing));\n\nPlots.savefig(plt_graph,\"graph1_layout.svg\");\n\nplt_matrix = Plots.spy(graph1,node_labels = true,markersize = 15);   \n\nPlots.savefig(plt_matrix,\"matrix1_layout.svg\");","category":"page"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"<img src=\"../graph1_layout.svg\" alt=\"graph1\" width=\"400\"/>","category":"page"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"<img src=\"../matrix1_layout.svg\" alt=\"matrix1\" width=\"400\"/>","category":"page"},{"location":"documentation/modeling/#Hierarchical-Modeling","page":"Modeling","title":"Hierarchical Modeling","text":"","category":"section"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"A fundamental feature of using optigraphs is that it is possible to create subgraphs (i.e. sub-optigraphs) within an optigraph.  This enables a hierarchical style of modeling that retains its modular aspects. Subgraphs are defined using the add_subgraph! function which embeds an optigraph as a subgraph within a higher level optigraph. This is demonstrated in the below snippets.  ","category":"page"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"First, we create two new optigraphs in the same fashion we did above.","category":"page"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"julia> graph2 = OptiGraph();\n\njulia> @optinode(graph2,nodes2[1:3]);\n\njulia>  for node in getnodes(graph2)\n            @variable(node, x >= 0)\n            @variable(node, y >= 2)\n            @constraint(node,x + y >= 5)\n            @objective(node, Min, y)\n        end\n\njulia> @linkconstraint(graph2, nodes2[1][:x] + nodes2[2][:x] + nodes2[3][:x] == 5);\n\njulia> graph3 = OptiGraph();\n\njulia> @optinode(graph3,nodes3[1:3]);\n\njulia>  for node in getnodes(graph3)\n            @variable(node, x >= 0)\n            @variable(node, y >= 2)\n            @constraint(node,x + y >= 5)\n            @objective(node, Min, y)\n        end\n\njulia> @linkconstraint(graph3, nodes3[1][:x] + nodes3[2][:x] + nodes3[3][:x] == 7);","category":"page"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"Now we have three optigraphs (graph1,graph2, and graph3), each with their own local optinodes and linking constraints (which induce optiedges).   These optigraphs can be embedded into a higher level optigraph with the following snippet:","category":"page"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"julia> graph0 = OptiGraph()\nOptiGraph:\nlocal nodes: 0, total nodes: 0\nlocal link constraints: 0, total link constraints 0\nlocal subgraphs: 0, total subgraphs 0\n\njulia> add_subgraph!(graph0,graph1)\nOptiGraph:\nlocal nodes: 0, total nodes: 3\nlocal link constraints: 0, total link constraints 1\nlocal subgraphs: 1, total subgraphs 1\n\njulia> add_subgraph!(graph0,graph2)\nOptiGraph:\nlocal nodes: 0, total nodes: 6\nlocal link constraints: 0, total link constraints 2\nlocal subgraphs: 2, total subgraphs 2\n\njulia> add_subgraph!(graph0,graph3)\nOptiGraph:\nlocal nodes: 0, total nodes: 9\nlocal link constraints: 0, total link constraints 3\nlocal subgraphs: 3, total subgraphs 3","category":"page"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"Here, we see the distinction between local and global (total) elements. For instance, after we add all three subgraphs the higher level graph0, we see that graph0 contains 0 local optinodes, but contains 9 total optinodes which are elements of its subgraphs. This hierarchical distinction is also made for linking constraints (i.e. optiedges), as well as subgraphs.  With this hierarhical style of modeling, subgraphs can be nested recursively such that an optigraph might contain local subgraphs, and the highest level optigraph contains all of the subgraphs.","category":"page"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"A key benefit of this hierarchical approach is that linking constraints can be expressed both locally and globally.  For instance, we can now add a linking constraint to graph0 that connects optinodes in its subgraphs like following:","category":"page"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"julia> @linkconstraint(graph0,nodes[3][:x] + nodes2[2][:x] + nodes3[1][:x] == 10)\nLinkConstraintRef(1, OptiEdge w/ 1 Constraint(s))\n\njulia> println(graph0)\nOptiGraph:\nlocal nodes: 0, total nodes: 9\nlocal link constraints: 1, total link constraints 4\nlocal subgraphs: 3, total subgraphs 3","category":"page"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"We now observe that graph0 contains 1 local linking constraint, and 4 total linking constraints (by including its subgraphs). Put another way, the local linking constraint in graph0 is a global constraint that connects each of its subgraphs. This hierarchical style of modeling facilitates the construction of optimization problems that include diverse model components.  For instance, a power system could be modeled separately from a natural gas system and they could be coupled in a higher level combined optigraph.  The hierarchical structure also enables the use of distributed optimization solvers which we discuss more in the Solvers section.","category":"page"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"We can lastly plot the hierarchical optigraph and see the nested subgraph structure.","category":"page"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"    using Plasmo\n    graph1 = OptiGraph()\n    @optinode(graph1,n1)\n    @optinode(graph1,nodes[2:3])\n\n    for node in getnodes(graph1)\n        @variable(node,x >= 0)\n        @variable(node, y >= 2)\n        @constraint(node,x + y >= 3)\n        @objective(node, Min, y)\n    end\n\n    @linkconstraint(graph1, n1[:x] + nodes[2][:x] + nodes[3][:x] == 3)\n\n    graph2 = OptiGraph();\n\n    @optinode(graph2,nodes2[1:3]);\n\n    for node in getnodes(graph2)\n        @variable(node, x >= 0)\n        @variable(node, y >= 2)\n        @constraint(node,x + y >= 5)\n        @objective(node, Min, y)\n    end\n\n    @linkconstraint(graph2, nodes2[1][:x] + nodes2[2][:x] + nodes2[3][:x] == 5);\n\n    graph3 = OptiGraph();\n\n    @optinode(graph3,nodes3[1:3]);\n\n    for node in getnodes(graph3)\n        @variable(node, x >= 0)\n        @variable(node, y >= 2)\n        @constraint(node,x + y >= 5)\n        @objective(node, Min, y)\n    end\n\n    @linkconstraint(graph3, nodes3[1][:x] + nodes3[2][:x] + nodes3[3][:x] == 7)\n\n    graph0 = OptiGraph()\n    add_subgraph!(graph0,graph1)\n    add_subgraph!(graph0,graph2)\n    add_subgraph!(graph0,graph3)\n\n    @linkconstraint(graph0,nodes[3][:x] + nodes2[2][:x] + nodes3[1][:x] == 10)","category":"page"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"using Plots\n\nfor (i,node) in enumerate(all_nodes(graph0))\n    node.label = \"n$i\"\nend\n\nplt_graph0 = Plots.plot(graph0,node_labels = true,markersize = 60,labelsize = 30,linewidth = 4,subgraph_colors = true,\nlayout_options = Dict(:tol => 0.001,:C => 2, :K => 4, :iterations => 5));\n\nPlots.savefig(plt_graph0,\"graph0_layout.svg\");\n\nplt_matrix0 = Plots.spy(graph0,node_labels = true,subgraph_colors = true,markersize = 16);\n\nPlots.savefig(plt_matrix0,\"matrix0_layout.svg\");","category":"page"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"<img src=\"../graph0_layout.svg\" alt=\"graph0\" width=\"400\"/>","category":"page"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"<img src=\"../matrix0_layout.svg\" alt=\"matrix0\" width=\"400\"/>","category":"page"},{"location":"documentation/modeling/#Query-OptiGraph-Attributes","page":"Modeling","title":"Query OptiGraph Attributes","text":"","category":"section"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"There are a few primary function which can be used to query optigraph attributes. getnodes can be used to retrieve an array of the local optinodes in an optigraph, whereas all_nodes will recursively retrieve all of the optinodes in an optigraph, including the nodes in its subgraphs.","category":"page"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"julia> getnodes(graph1)\n3-element Array{OptiNode,1}:\n OptiNode w/ 2 Variable(s)\n OptiNode w/ 2 Variable(s)\n OptiNode w/ 2 Variable(s)\n\njulia> getnodes(graph0)\n0-element Array{OptiNode,1}\n\njulia> all_nodes(graph0)\n9-element Array{OptiNode,1}:\n OptiNode w/ 2 Variable(s)\n OptiNode w/ 2 Variable(s)\n OptiNode w/ 2 Variable(s)\n OptiNode w/ 2 Variable(s)\n OptiNode w/ 2 Variable(s)\n OptiNode w/ 2 Variable(s)\n OptiNode w/ 2 Variable(s)\n OptiNode w/ 2 Variable(s)\n OptiNode w/ 2 Variable(s)\n","category":"page"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"It is possible to query for optiedges, linking constraints, and subgraphs in the same way. We can query optiedges:","category":"page"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"julia> getedges(graph1)\n1-element Array{OptiEdge,1}:\n OptiEdge w/ 1 Constraint(s)\n\njulia> getedges(graph0)\n1-element Array{OptiEdge,1}:\n OptiEdge w/ 1 Constraint(s)\n\njulia> all_edges(graph0)\n4-element Array{OptiEdge,1}:\n OptiEdge w/ 1 Constraint(s)\n OptiEdge w/ 1 Constraint(s)\n OptiEdge w/ 1 Constraint(s)\n OptiEdge w/ 1 Constraint(s)","category":"page"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"query linking constraints:","category":"page"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"julia> getlinkconstraints(graph1)\n1-element Array{LinkConstraint,1}:\n LinkConstraint: x + x + x, MathOptInterface.EqualTo{Float64}(3.0)\n\njulia> getlinkconstraints(graph0)\n1-element Array{LinkConstraint,1}:\n LinkConstraint: x + x + x, MathOptInterface.EqualTo{Float64}(10.0)\n\njulia> all_linkconstraints(graph0)\n4-element Array{LinkConstraint,1}:\n LinkConstraint: x + x + x, MathOptInterface.EqualTo{Float64}(3.0)\n LinkConstraint: x + x + x, MathOptInterface.EqualTo{Float64}(5.0)\n LinkConstraint: x + x + x, MathOptInterface.EqualTo{Float64}(7.0)\n LinkConstraint: x + x + x, MathOptInterface.EqualTo{Float64}(10.0)","category":"page"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"and query subgraphs:","category":"page"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"julia> getsubgraphs(graph0)\n3-element Array{AbstractOptiGraph,1}:\n OptiGraph:\nlocal nodes: 3, total nodes: 3\nlocal link constraints: 1, total link constraints 1\nlocal subgraphs: 0, total subgraphs 0\n\n OptiGraph:\nlocal nodes: 3, total nodes: 3\nlocal link constraints: 1, total link constraints 1\nlocal subgraphs: 0, total subgraphs 0\n\n OptiGraph:\nlocal nodes: 3, total nodes: 3\nlocal link constraints: 1, total link constraints 1\nlocal subgraphs: 0, total subgraphs 0","category":"page"},{"location":"documentation/modeling/#Methods","page":"Modeling","title":"Methods","text":"","category":"section"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"Modeling with an OptiGraph encompasses various useful methods.  It is important to note that both the OptiGraph and the OptiNode are extensions of the JuMP.AbstractModel and can use many of the same methods. We refer to the JuMP Documentation which describes most methods. Some select functions are also listed here.","category":"page"},{"location":"documentation/modeling/#OptiGraph-Functions","page":"Modeling","title":"OptiGraph Functions","text":"","category":"section"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"OptiGraph\n@optinode\nOptiNode\nadd_node!\ngetnode\ngetnodes\nfind_node\nis_node_variable\nBase.getindex(::OptiGraph,::OptiNode)\nBase.getindex(::OptiGraph,::OptiEdge)\nnodevalue\nall_nodes\nset_model\n@NLnodeconstraint\n@linkconstraint\nOptiEdge\ngetedge\ngetedges\nall_edges\nLinkConstraint\ngetlinkconstraints\nall_linkconstraints\nadd_subgraph!\ngetsubgraphs\nall_subgraphs","category":"page"},{"location":"documentation/modeling/#Plasmo.OptiGraph","page":"Modeling","title":"Plasmo.OptiGraph","text":"OptiGraph()\n\nCreate an empty OptiGraph. An OptiGraph extends JuMP.AbstractModel and supports many JuMP.Model functions.\n\n\n\n\n\n","category":"type"},{"location":"documentation/modeling/#Plasmo.@optinode","page":"Modeling","title":"Plasmo.@optinode","text":"@optinode(optigraph, expr...)\n\nAdd a new optinode to optigraph. The expression expr can either be\n\nof the form varname creating a single optinode with the variable name varname\nof the form varname[...] or [...] creating a container of optinodes using JuMP Containers\n\n\n\n\n\n","category":"macro"},{"location":"documentation/modeling/#Plasmo.OptiNode","page":"Modeling","title":"Plasmo.OptiNode","text":"OptiNode()\n\nCreates an empty OptiNode.  Does not add it to a graph.\n\n\n\n\n\n","category":"type"},{"location":"documentation/modeling/#Plasmo.add_node!","page":"Modeling","title":"Plasmo.add_node!","text":"add_node!(graph::OptiGraph)\n\nCreate a new OptiNode and add it to graph. Returns the added optinode.\n\nadd_node!(graph::OptiGraph,m::JuMP.Model)\n\nAdd a new optinode to graph and set its model to the JuMP.Model m.\n\nadd_node!(graph::OptiGraph,optinode::OptiNode)\n\nAdd the existing optinode (Created with OptiNode()) to graph.\n\n\n\n\n\n","category":"function"},{"location":"documentation/modeling/#Plasmo.getnode","page":"Modeling","title":"Plasmo.getnode","text":"getnode(graph::OptiGraph) = graph.optinodes\n\nRetrieve the local optinode in graph at index. This does not look up nodes that could be in subgraphs.\n\n\n\n\n\n","category":"function"},{"location":"documentation/modeling/#Plasmo.getnodes","page":"Modeling","title":"Plasmo.getnodes","text":"getnodes(graph::OptiGraph) = graph.optinodes\n\nRetrieve the optinodes in graph.\n\n\n\n\n\n","category":"function"},{"location":"documentation/modeling/#Plasmo.find_node","page":"Modeling","title":"Plasmo.find_node","text":"find_node(graph::OptiGraph,index::Int64)\n\nFind the optinode in graph at index. This traverses all of the nodes in the subgraphs of graph.\n\n\n\n\n\n","category":"function"},{"location":"documentation/modeling/#Plasmo.is_node_variable","page":"Modeling","title":"Plasmo.is_node_variable","text":"is_node_variable(node::OptiNode,var::JuMP.AbstractVariableRef)\n\nChecks whether the variable var belongs to the optinode node.\n\n\n\n\n\n","category":"function"},{"location":"documentation/modeling/#Base.getindex-Tuple{OptiGraph,OptiNode}","page":"Modeling","title":"Base.getindex","text":"Base.getindex(graph::OptiGraph,node::OptiNode)\n\nRetrieve the index of the optinode node in graph.\n\n\n\n\n\n","category":"method"},{"location":"documentation/modeling/#Base.getindex-Tuple{OptiGraph,OptiEdge}","page":"Modeling","title":"Base.getindex","text":"Base.getindex(graph::OptiGraph,optiedge::OptiEdge)\n\nRetrieve the index of the optiedge in graph.\n\n\n\n\n\n","category":"method"},{"location":"documentation/modeling/#Plasmo.nodevalue","page":"Modeling","title":"Plasmo.nodevalue","text":"nodevalue(var::JuMP.VariableRef)\n\nGet the current value of var\n\nnodevalue(expr::JuMP.GenericAffExpr)\n\nGet the current value of expr which is JuMP.GenericAffExpr\n\nnodevalue(expr::JuMP.GenericQuadExpr)\n\nGet the current value of expr which is a JuMP.GenericQuadExpr\n\n\n\n\n\n","category":"function"},{"location":"documentation/modeling/#Plasmo.all_nodes","page":"Modeling","title":"Plasmo.all_nodes","text":"all_nodes(graph::OptiGraph)\n\nRecursively collect nodes in a optigraph from each of its subgraphs\n\n\n\n\n\n","category":"function"},{"location":"documentation/modeling/#Plasmo.set_model","page":"Modeling","title":"Plasmo.set_model","text":"set_model(node::OptiNode,m::AbstractModel)\n\nSet the model on a node.  This will delete any link-constraints the node is currently part of\n\n\n\n\n\n","category":"function"},{"location":"documentation/modeling/#Plasmo.@NLnodeconstraint","page":"Modeling","title":"Plasmo.@NLnodeconstraint","text":"@NLnodeconstraint(node,args...)\n\nAdd a nonlinear constraint to an optinode.  Wraps JuMP.@NLconstraint.  This method will deprecate once optinodes extend nonlinear JuMP functionality.\n\n\n\n\n\n","category":"macro"},{"location":"documentation/modeling/#Plasmo.@linkconstraint","page":"Modeling","title":"Plasmo.@linkconstraint","text":"@linkconstraint(graph::OptiGraph, expr)\n\nAdd a linking constraint described by the expression expr.\n\n@linkconstraint(graph::OptiGraph, ref[i=..., j=..., ...], expr)\n\nAdd a group of linking  constraints described by the expression expr parametrized by i, j, ...\n\nThe @linkconstraint macro works the same way as the JuMP.@constraint macro.\n\n\n\n\n\n","category":"macro"},{"location":"documentation/modeling/#Plasmo.OptiEdge","page":"Modeling","title":"Plasmo.OptiEdge","text":"OptiEdge\n\nThe OptiEdge type.  Typically created from @linkconstraint.  Contains the set of its supporting optionodes, as well as references to its underlying linking constraints.\n\n\n\n\n\n","category":"type"},{"location":"documentation/modeling/#Plasmo.getedge","page":"Modeling","title":"Plasmo.getedge","text":"getedge(graph::OptiGraph,index::Int64)\n\nRetrieve the local optiedge in graph at index\n\ngetedge(graph::OptiGraph,nodes::OrderedSet{OptiNode})\n\nRetrieve the optiedge in graph that connects the optinodes in the OrderedSet of nodes.\n\ngetedge(graph::OptiGraph,nodes::OptiNode...)\n\nRetrieve the optiedge in graph that connects nodes.\n\n\n\n\n\n","category":"function"},{"location":"documentation/modeling/#Plasmo.getedges","page":"Modeling","title":"Plasmo.getedges","text":"getedges(graph::OptiGraph) = graph.optiedges\n\nRetrieve the local optiedges in graph.\n\n\n\n\n\n","category":"function"},{"location":"documentation/modeling/#Plasmo.all_edges","page":"Modeling","title":"Plasmo.all_edges","text":"all_edges(graph::OptiGraph)\n\nRetrieve all optiedges in graph, includes edges in subgraphs of graph.\n\n\n\n\n\n","category":"function"},{"location":"documentation/modeling/#Plasmo.LinkConstraint","page":"Modeling","title":"Plasmo.LinkConstraint","text":"LinkConstraint{F <: JuMP.AbstractJuMPScalar,S <: MOI.AbstractScalarSet} <: AbstractLinkConstraint\n\nType inherits JuMP.AbstractConstraint.  Contains a func and set used to describe coupling between optinodes.\n\nLinkConstraint(con::JuMP.ScalarConstraint)\n\nCreates a linking constraint from a JuMP.ScalarConstraint.\n\nLinkConstraint(ref::LinkConstraintRef)\n\nRetrieves a linking constraint from a LinkConstraintRef.\n\n\n\n\n\n","category":"type"},{"location":"documentation/modeling/#Plasmo.getlinkconstraints","page":"Modeling","title":"Plasmo.getlinkconstraints","text":"getlinkconstraints(graph::OptiGraph)::Vector{LinkConstraint}\n\nRetrieve the local linking constraints in graph. Returns a vector of the linking constraints.\n\n\n\n\n\n","category":"function"},{"location":"documentation/modeling/#Plasmo.all_linkconstraints","page":"Modeling","title":"Plasmo.all_linkconstraints","text":"all_linkconstraints(graph::OptiGraph)::Vector{LinkConstraint}\n\nRetrieve all of the linking constraints in graph, including linking constraints in its subgraphs. Returns a vector of the linking constraints.\n\n\n\n\n\n","category":"function"},{"location":"documentation/modeling/#Plasmo.add_subgraph!","page":"Modeling","title":"Plasmo.add_subgraph!","text":"add_subgraph!(graph::OptiGraph,subgraph::OptiGraph)\n\nAdd the sub-optigraph subgraph to the higher level optigraph graph. Returns the original graph\n\n\n\n\n\n","category":"function"},{"location":"documentation/modeling/#Plasmo.getsubgraphs","page":"Modeling","title":"Plasmo.getsubgraphs","text":"getsubgraphs(optigraph::OptiGraph)::Vector{OptiGraph}\n\nRetrieve the local subgraphs of optigraph.\n\n\n\n\n\n","category":"function"},{"location":"documentation/modeling/#Plasmo.all_subgraphs","page":"Modeling","title":"Plasmo.all_subgraphs","text":"all_subgraphs(optigraph::OptiGraph)::Vector{OptiGraph}\n\nRetrieve all of the contained subgraphs of optigraph, including nested subgraphs. The order of the subgraphs in the returned vector starts with the local subgraphs in optigraph and then appends the nested subgraphs for each local subgraph.\n\n\n\n\n\n","category":"function"},{"location":"documentation/modeling/#Extended-JuMP-Functions","page":"Modeling","title":"Extended JuMP Functions","text":"","category":"section"},{"location":"documentation/modeling/","page":"Modeling","title":"Modeling","text":"JuMP.all_variables(::OptiNode)\nJuMP.set_optimizer(::OptiGraph,::Any)\nJuMP.objective_function(::OptiGraph)\nJuMP.value(::OptiNode,::VariableRef)\nJuMP.num_variables(::OptiGraph)\nJuMP.num_constraints(::OptiGraph)","category":"page"},{"location":"documentation/modeling/#JuMP.all_variables-Tuple{OptiNode}","page":"Modeling","title":"JuMP.all_variables","text":"JuMP.all_variables(node::OptiNode)::Vector{JuMP.VariableRef}\n\nRetrieve all of the variables on the optinode node.\n\n\n\n\n\n","category":"method"},{"location":"documentation/modeling/#JuMP.set_optimizer-Tuple{OptiGraph,Any}","page":"Modeling","title":"JuMP.set_optimizer","text":"JuMP.set_optimizer(graph::OptiGraph,optimizer::Any)\n\nSet an optimizer for the optigraph graph.\n\n\n\n\n\n","category":"method"},{"location":"documentation/modeling/#JuMP.objective_function-Tuple{OptiGraph}","page":"Modeling","title":"JuMP.objective_function","text":"JuMP.objective_function(graph::OptiGraph)\n\nRetrieve the current graph objective function.\n\n\n\n\n\n","category":"method"},{"location":"documentation/modeling/#JuMP.value-Tuple{OptiNode,VariableRef}","page":"Modeling","title":"JuMP.value","text":"JuMP.value(node::OptiNode,vref::VariableRef)\n\nGet the variable value of vref on the optinode node.\n\n\n\n\n\n","category":"method"},{"location":"documentation/modeling/#JuMP.num_variables-Tuple{OptiGraph}","page":"Modeling","title":"JuMP.num_variables","text":"JuMP.num_variables(graph::OptiGraph)\n\nRetrieve the number of local node variables in graph. Does not include variables in subgraphs.\n\n\n\n\n\n","category":"method"},{"location":"documentation/modeling/#JuMP.num_constraints-Tuple{OptiGraph}","page":"Modeling","title":"JuMP.num_constraints","text":"JuMP.num_constraints(graph::OptiGraph)\n\nRetrieve the number of local node constraints in graph. Does not include constraints in subgraphs.\n\n\n\n\n\n","category":"method"},{"location":"documentation/plotting/#Plotting","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"documentation/plotting/","page":"Plotting","title":"Plotting","text":"Plasmo.jl extends the Plots.plot and Plots.spy methods from the Plots.jl Julia package.","category":"page"},{"location":"documentation/plotting/","page":"Plotting","title":"Plotting","text":"    Plots.plot(::OptiGraph)\n    Plots.spy(::OptiGraph)","category":"page"},{"location":"documentation/plotting/#RecipesBase.plot-Tuple{OptiGraph}","page":"Plotting","title":"RecipesBase.plot","text":"Plots.plot(graph::OptiGraph; node_labels = false, subgraph_colors = false, node_colors = false, linewidth = 2.0,linealpha = 1.0, markersize = 30,labelsize = 20, markercolor = :grey,\nlayout_options = Dict(:tol => 0.01,:C => 2, :K => 4, :iterations => 2),\nplt_options = Dict(:legend => false,:framestyle => :box,:grid => false,:size => (800,800),:axis => nothing),\nline_options = Dict(:linecolor => :blue,:linewidth => linewidth,:linealpha => linealpha))\n\nPlot a graph layout of the optigraph graph. The following keyword arguments can be provided to customize the graph layout.\n\nnode_labels = false: whether to label nodes using the corresponding optinode label attribute.\nsubgraph_colors = false: whether to color nodes according to their subgraph.\nnode_colors = false: whether to color nodes.  Only active if subgraph_colors = false.\nlinewidth = 2.0: the linewidth attribute for each edge in graph.\nlinealpha = 1.0: the linealpha attribute for each edge in graph.\nmarkersize = 30: the markersize which determines the size of each node in graph.\nlabelsize = 20: the size for each node label.  Only active if node_labels = true.\nmarkercolor = :grey: the color for each node.\nlayout_options = Dict(:tol => 0.01,:C => 2, :K => 4, :iterations => 2): dictionary with options for the layout algorithm.\ntol: permitted distance between a current and calculated co-ordinate.\nC,K: scaling parameters.\niterations: number of iterations used to apply forces.\nplt_options = Dict(:legend => false,:framestyle => :box,:grid => false,:size => (800,800),:axis => nothing): dictionary with primary plotting options.\nlegend: whether to include legend, or legend position.\nframestyle: style of frame used for plot.\nsize: size of the resulting plot.\naxis: whether to include the axis.  The axis typically does not make sense for a graph layout plot.\nIt is also possible to use various plotting options compatible with Plots.scatter from the Plots.jl package.\nline_options = Dict(:linecolor => :blue,:linewidth => linewidth,:linealpha => linealpha): line plotting options used to display edges in the graph.\nlinecolor: color to use for each line.\nlinewidth: linewidth to use for each edge.  Defaults to the above option.\nlinealpha: linealpha to use for each edge. Default to the above option.\n\n\n\n\n\n","category":"method"},{"location":"documentation/plotting/#Plots.spy-Tuple{OptiGraph}","page":"Plotting","title":"Plots.spy","text":"Plots.spy(graph::OptiGraph;node_labels = false,labelsize = 24,subgraph_colors = false,node_colors = false,markersize = 1)\n\nPlot a matrix visualization of the optigraph: graph. The following keyword arguments can be provided to customize the matrix visual.\n\nnode_labels = false: whether to label nodes using the corresponding optinode label attribute.\nlabelsize: the size for each node label.  Only active if node_labels = true.\nsubgraph_colors = false: whether to color nodes according to their subgraph.\nnode_colors = false: whether to color nodes.  Only active if subgraph_colors = false.\nmarkersize = 1: Size of the linking constraints in the matrix representation.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/tutorials/#Tutorials","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"Here we tutorials that cover more detailed aspects of Plasmo.jl and show how it can be used to create and solve complex optimization problems.","category":"page"},{"location":"tutorials/tutorials/#Optimal-Control-of-a-Natural-Gas-Network","page":"Tutorials","title":"Optimal Control of a Natural Gas Network","text":"","category":"section"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"This tutorial shows how to model a natural-gas network optimal control problem by constructing a hierarchical optigraph.   We show the resulting structure of the optimization problem and demonstrate how to use Plasmo.jl to decompose the problem and use the PipsSolver to distribute and solve the problem in parallel. The details of this model and a description of its parameters can be found in this manuscript. The actual implementation of this tutorial can be found in this git repository.","category":"page"},{"location":"tutorials/tutorials/#Problem-Description","page":"Tutorials","title":"Problem Description","text":"","category":"section"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"We consider the system of connected pipelines in series shown in the below figure. This linear network includes a gas supply at one end, a time-varying demand at the other end, and twelve compressor stations. The gas junctions connect thirteen pipelines which forms an optigraph with a linear topology.","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"(Image: 13pipeline_sketch)","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"We seek to solve an optimal control problem that maximizes revenue over a 24 hour time period given a forecast of gas demand profiles. That is, we wish to obtain a compressor control policy that will meet the gas demand at junction j_25, whilst simultaneously minimizing compressor costs and meeting operational constraints. In the formulation below, alpha_ell and P_ellt are the compression cost ($/kW), and compression power for each compressor ell at time t, and alpha_d and f^target_dt are the demand price and target demand flow for each demand d at time t. This formulation includes physical equations and constraints that describe the network junctions, the pipeline dynamics, and compressors.   The network link equations describe how the devices within the topology are coupled together such as conservation of mass and boundary conditions. The sets that describe the elements of the optimization problem are also presented here.","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"beginaligned\n    min_ substack  eta_elltf_jdt   ell in mathcalL_c d in mathcalD_j j in mathcalJ t in mathcalT quad \n    sum_substackell in mathcalL_c  t in mathcalT alpha_ell P_ellt -\n    sum_substackd in mathcalD_j j in mathcalJ   t in mathcalT alpha_jd f_jdt \n     st quad  textJunction Limits   \n      textPipeline Dynamics    \n      textCompressor Equations   \n      textNetwork Link Equations \nendaligned","category":"page"},{"location":"tutorials/tutorials/#Sets-used-for-optimization-problem","page":"Tutorials","title":"Sets used for optimization problem","text":"","category":"section"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"Set Description Elements\nmathcalJ Set of gas network nodes j in mathcalJ\nmathcalS Set of gas supplies s in mathcalS\nmathcalD Set of gas demands d in mathcalD\nmathcalD_j Set of gas demands on junction j d in mathcalD_j\nmathcalS_j Set of gas supplies on junction j s in mathcalS_j\nmathcalL Set of gas network links ell in mathcalL\nmathcalL_p Set of network pipeline links mathcalL_p subseteq mathcalL\nmathcalL_c Set of network compressor links mathcalL_c subseteq mathcalL\nmathcalX Set of spatial discretization points k in mathcalX\nmathcalT Set of temporal discretization points t in mathcalT","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"The following sections describe each component of the network in further detail.","category":"page"},{"location":"tutorials/tutorials/#Junction-OptiGraph","page":"Tutorials","title":"Junction OptiGraph","text":"","category":"section"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"The gas junctions in a gas network describe the connection points between pipelines and compressors.  The junction model is described by the below equations, where theta_jt is the pressure at junction j and time t. underlinetheta_j is the lower pressure bound for the junction, overlinetheta_j is the upper pressure bound, f_jdt^target is the target demand flow for demand d on junction j and overlinef_js is the available gas generation from supply s on junction j.","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"beginaligned\n     underlinetheta_j le theta_jt le overlinetheta_j  quad j in mathcalJ  t in mathcalT \n    0 le f_jdt le f_jdt^target quad d in mathcalD_j  j in mathcalJ  t in mathcalT \n    0 le f_jst le overlinef_js quad s in mathcalS_j  j in mathcalJ  t in mathcalT\nendaligned","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"The optigraph that is used to create the junction model is given by the following julia function.  We define the function create_junction_model which accepts junction specific data and the number of time periods nt.  We create the optigraph graph, add an optignode for each time interval (using @optinode), and then create the variables and constraints for each node in a loop.  We also use the JuMP specific @expression macro to refer to expressions for total gas supplied, total gas delivered, and total cost for convenience.  The junction optigraph is finally returned from the function","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"#Define function to create junction model-graph\nfunction create_junction_model(data,nt)            \n    graph = OptiGraph()                           \n\n    #Add model-node for each time interval\n    @optinode(graph,nodes[1:nt])\n\n    #query number of supply and demands on the junction\n    n_demands = length(data[:demand_values])\n    n_supplies = length(data[:supplies])\n\n    #Loop and create variables, constraints, and objective for each model-node\n    for (i,node) in enumerate(nodes)\n        @variable(node, data[:pmin] <= pressure <= data[:pmax], start = 60)\n        @variable(node, 0 <= fgen[1:n_supplies] <= 200, start = 10)\n        @variable(node, fdeliver[1:n_demands] >= 0)\n        @variable(node, fdemand[1:n_demands] >= 0)\n\n        @constraint(node,[d = 1:n_demands],fdeliver[d] <= fdemand[d])\n\n        @expression(node, total_supplied, sum(fgen[s] for s = 1:n_supplies))\n        @expression(node, total_delivered,sum(fdeliver[d] for d = 1:n_demands))\n        @expression(node, total_delivercost,sum(1000*fdeliver[d] for d = 1:n_demands))\n\n        @objective(node,Min,total_delivercost)\n    end                                             \n\n    #Return the junction OptiGraph\n    return graph                                   \nend","category":"page"},{"location":"tutorials/tutorials/#Compressor-OptiGraph","page":"Tutorials","title":"Compressor OptiGraph","text":"","category":"section"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"Compressors constitute the primary control decisions in the optimal control problem and are described by the following simple formulation. We use an ideal isentropic compressor model where eta_ellt, p_ellt^in, and p_ellt^out are the compression ratio, suction pressure, and discharge pressure at time t, and P_ellt is power at time t. We also introduceduce the dummy variables f_ellt^in and f_ellt^out to be consistent with the pipeline model in the next section.","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"beginaligned\n    p_ellt^out = eta_ellt p_ellt^in quad ell in mathcalL_cquad t in mathcalT \n    P_ellt = c_p cdot T cdot f_ellt left(left(fracp_ellt^outp_ellt^inright)^fracgamma-1gamma-1right)\n    quad ell in mathcalL_cquad t in mathcalT\n    f_ellt = f_ellt^in = f_ellt^out quad ell in mathcalL_cquad t in mathcalT\nendaligned","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"The compressor optigraph construction is straightforward as shown by the following Julia code. Like the above model, we define a function called create_compressor_model to create a compressor optigraph given data and number of time periods nt. We create the compressor optigraph by creating nodes, variables, and constraints, as well as expressions to refer to flow in and out of each compressor. We lastly return the created optigraph from the function.","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"function create_compressor_model(data,nt)                        \n    #Create compressor model-graph\n    graph = OptiGraph()                                          \n    @optinode(graph,nodes[1:nt])\n\n    #Setup variables, constraints, and objective\n    for node in nodes\n        @variable(node, 1 <= psuction <= 100)\n        @variable(node, 1 <= pdischarge <= 100)\n        @variable(node, 0 <= power <= 1000)\n        @variable(node, flow >= 0)\n        @variable(node, 1 <= eta <= 2.5)\n        @NLnodeconstraint(node, pdischarge == eta*psuction)\n        @NLnodeconstraint(node, power == c4*flow*((pdischarge/psuction)^om-1) )\n        @objective(node, Min, cost*power*(dt/3600.0))\n    end                                                         \n\n    #Create references for flow in and out\n    @expression(graph,fin[t=1:nt],nodes[t][:flow])               \n    @expression(graph,fout[t=1:nt],nodes[t][:flow])          \n\n    #Return compressor OptiGraph\n    return graph                                              \nend","category":"page"},{"location":"tutorials/tutorials/#Pipeline-OptiGraph","page":"Tutorials","title":"Pipeline OptiGraph","text":"","category":"section"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"We now implement the pipeline equations to describe the dynamic transport throughout the gas network. For each pipeline model we assume isothermal flow through horizontal segments with constant pipe friction.  We ultimately produce the following discretized pipeline model.","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"beginaligned\n     fracp_ellt+1k - p_elltkDelta t = -c_1ell fracf_ellt+1k+1 - f_ellt+1kDelta x_ell ell in mathcalL_pt in mathcalT k in mathcalX_ell \n     fracf_ellt+1k - f_elltkDelta t = -c_2ellfracp_ellt+1k+1 - p_ellt+1kDelta x_ell - c_3ellfracf_ellt+1k f_ellt+1kp_ellt+1k ell in mathcalL_p t in mathcalT k in mathcalX_ell  \n     f_elltN_x = f_ellt^outquad ell in mathcalL_p quad t in mathcalT \n     f_ellt1 = f_ellt^inquad ell in mathcalL_p quad t in mathcalT    \n     p_elltN_x = p_ellt^outquad ell in mathcalL_p quad t in mathcalT \n     p_ellt1 = p_ellt^inquad ell in mathcalL_p quad t in mathcalT    \nendaligned","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"The model contains the transport equations defined in terms of pressure and mass flow rate.  It also contains dummy flows and pressures which represent in the inlet and outlet flow and pressure into each pipeline segment.  We also express a steady-state initial condition which is typical for this control problem and is given by the following equations.","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"beginaligned\n     fracf_ell1k+1 - f_ell1kDelta x = 0  quad ell in mathcalL_p k in mathcalX_ell \n     c_2ellfracp_ell1k - p_ell1kDelta x + c_3fracf_ell1k f_ell1kp_ell1k = 0\n    quad ell in mathcalL_p k in mathcalX_ell\nendaligned","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"Lastly, we require the total line-pack in each segment (i.e. the inventory of gas) to be refilled at the end of the planning horizon. This is represented by the following approximation of line-pack and constraint for refilling it.","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"beginaligned\n     m_ellt = fracA_ellc^2 sum_k=1^N_x p_elltk Delta x_ellquad ell in mathcalL_p t in mathcalT \n     m_ellN_t ge m_ell1 quad ell in mathcalL_p\nendaligned","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"We express the pipeline model with optinodes distributed on a space-time grid. Specifically, the nodes of each pipeline optigraph form a nt x nx  grid wherein pressure and flow variables are assigned to each node. Flow dynamics within pipelines are then expressed with linking constraints that describe the discretized PDE equations for mass and momentum using finite differences. We lastly include linking constraints that represent the initial steady-state condition and line-pack constraint.","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"function create_pipeline_model(data,nt,nx)                             \n    #Unpack data\n    c1 = data[:c1]; c2 = data[:c2]; c3 = data[:c3]                     \n    dx = data[:pipe_length] / (nx - 1)\n\n    #Create pipeline model-graph\n    graph = OptiGraph()\n\n    #Create grid of optinodes\n    @node(mg,grid[1:nt,1:nx])                                         \n\n    #Create variables on each node in the grid\n    for node in grid\n        @variable(node, 1 <= px <= 100)\n        @variable(node, 0 <= fx <= 100)\n        @variable(node,slack >= 0)\n        @NLnodeconstraint(node, slack*px - c3*fx*fx == 0)\n    end\n\n    #Setup dummy variable references\n    @expression(mg,fin[t=1:nt],grid[:,1][t][:fx])\n    @expression(mg,fout[t=1:nt],grid[:,end][t][:fx])\n    @expression(mg,pin[t=1:nt],grid[:,1][t][:px])\n    @expression(mg,pout[t=1:nt],grid[:,end][t][:px])\n    @expression(mg,linepack[t=1:nt],c2/A*sum(grid[t,x][:px]*dx for x in 1:nx-1))          \n\n    #Finite differencing.  Backward difference in time from t, Forward difference in space from x.\n    @linkconstraint(mg, press[t=2:nt,x=1:nx-1],                                            \n    (grid[t,x][:px]-grid[t-1,x][:px])/dt +\n    c1*(grid[t,x+1][:fx] - grid[t,x][:fx])/dx == 0)\n\n    @linkconstraint(mg, flow[t=2:nt,x=1:nx-1],(grid[t,x][:fx] -\n    grid[t-1,x][:fx])/dt == -c2*(grid[t,x+1][:px] -\n    grid[t,x][:px])/dx - grid[t,x][:slack])\n\n    #Initial steady state\n    @linkconstraint(mg,ssflow[x=1:nx-1],grid[1,x+1][:fx] - grid[1,x][:fx] == 0)\n    @linkconstraint(mg,sspress[x = 1:nx-1], -c2*(grid[1,x+1][:px] -\n    grid[1,x][:px])/dx - grid[1,x][:slack] == 0)\n\n    #Refill pipeline linepack\n    @linkconstraint(mg,linepack[end] >= linepack[1])                     \n    return graph\nend","category":"page"},{"location":"tutorials/tutorials/#Network-OptiGraph","page":"Tutorials","title":"Network OptiGraph","text":"","category":"section"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"The network connections define the topology that connect junctions and equipment links (i.e. pipelines and compressors). Specifically, the network equations express mass conservation around each junction and boundary conditions for pipelines and compressors. Mass conservation around each junction j is given by the following equation.","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"beginaligned\n     sum_ellinmathcalL_rec(j) f^out_ellt - sum_ell inmathcalL_snd(j) f^in_ellt +\n    sum_sinmathcalS_jf_jst - sum_din mathcalD_jf_jdt = 0 quad j inmathcalJ\nendaligned","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"where we define mathcalL_rec(j) and mathcalL_snd(j) as the set of receiving and sending links to each junction j respectively.","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"The next equations define pipeline and compressor link boundary conditions.","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"beginaligned\n     p_ellt^in =  theta_rec(ell)t quad ell in mathcalL  t in mathcalT \n     p_ellt^out = theta_snd(ell)t quad ell in mathcalL  t in mathcalT\nendaligned","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"Here, theta_rec(ell)t and theta_snd(ell)t are the receiving and sending junction pressure for each link ell in mathcalL at time t.","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"The Julia code required to create the network optigraph is a bit more involved, but mostly because we have to define some data structures to capture the network topology. The below piece of code defines the function create_gas_network which accepts a dictionary of network data and calls the above defined functions to create the hierarchical optigraph. That is, the below code creates junction, compressor, and pipeline optigraphs, adds these optigraphs as subgraphs within a higher level network optigraph, and then creates linking constraints that couple the subgraphs to eachother in the form of mass conservation and boundary conditions.","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"function create_gas_network(net_data)              \n    pipe_data = net_data[:pipeline_data]\n    comp_data = net_data[:comp_data]\n    junc_data = net_data[:junc_data]\n    pipe_map = net_data[:pipe_map]; comp_map = net_data[:comp_map]\n\n    #Create OptiGraph for entire gas network\n    network = OptiGraph()                              \n    network[:pipelines] = [];network[:compressors] = [];network[:junctions] = []\n    j_map = Dict()\n\n    #Create device OptiGraphs and setup data structures\n    for j_data in junc_data                                 \n        junc= create_junction_optigraph(j_data)\n        add_subgraph!(network,junc); push!(network[:junctions],junc)\n        j_map[j_data[:id]] = junc\n        junc[:devices_in] = []; junc[:devices_out] = []\n    end\n    for p_data in pipe_data\n        pipe = create_pipeline_optigraph(p_data); push!(network[:pipelines],pipe)\n        add_subgraph!(network,pipe);\n        pipe[:junc_from] = j_map[p_data[:junc_from]]\n        pipe[:junc_to] = j_map[p_data[:junc_to]]\n        push!(pipe[:junc_from][:devices_out],pipe); push!(pipe[:junc_to][:devices_in],pipe)\n    end\n    for c_data in comp_data\n        comp = create_compressor_optigraph(c_data)\n        add_subgraph!(gas_network,comp); comp[:data] = c_data\n        comp[:junc_from] = j_map[c_data[:junc_from]]\n        comp[:junc_to] = j_map[c_data[:junc_to]]\n        push!(comp[:junc_from][:devices_out],comp); push!(comp[:junc_to][:devices_in],comp)\n    end                                                       \n\n    #Link pipelines in gas network\n    for pipe in network[:pipelines]                         \n        junc_from,junc_to = [pipe[:junc_from],pipe[:junc_to]]\n        @linkconstraint(network,[t = 1:nt],pipe[:pin][t] == junc_from[:pressure][t])\n        @linkconstraint(gas_network,[t = 1:nt],pipe[:pout][t] == junc_to[:pressure][t])\n    end\n\n    #Link compressors in gas network\n    for comp in network[:compressors]\n        junc_from,junc_to = [comp[:junc_from].comp[:junc_to]]\n        @linkconstraint(network,[t = 1:nt],comp[:pin][t] == junc_from[:pressure][t])\n        @linkconstraint(network,[t = 1:nt],comp[:pout][t]  == junc_to[:pressure][t])\n    end\n\n    #Link junctions in gas network\n    for junc in network[:junctions]\n        devices_in = junc[:devices_in]; devices_out = junc[:devices_out]\n\n        flow_in = [sum(device[:fout][t] for device in devices_in) for t = 1:nt]\n        flow_out = [sum(device[:fin][t] for device in devices_out) for t = 1:nt]\n\n        total_supplied = [junction[:total_supplied][t] for t = 1:nt]\n        total_delivered = [junction[:total_delivered][t] for t = 1:nt]\n\n        @linkconstraint(gas_network,[t = 1:nt], flow_in[t] - flow_out[t] +\n        total_supplied[t] - total_delivered[t] == 0)\n    end                                                 \n    return gas_network\nend","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"Using the abovie function, we can obtain a complete optigraph representation of the optimal control problem.  It is now possible to plot the graph layout using the functions in Plotting, but we have opted to export the graph structure and use the Gephi visualization to produce the below figure.  Here, the green colors correspond to compressor nodes, blue corresponds to junctions, and grey corresponds to pipleines.  Notice that the optigraph has captured the space-time structure of the optimization problem.  We also observe a cylindrical shape to the problem which results from the line-pack constraint which couples the initial and final time optinodes for each pipeline.","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"(Image: space_time)","category":"page"},{"location":"tutorials/tutorials/#Partitioning","page":"Tutorials","title":"Partitioning","text":"","category":"section"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"Now that we have an optigraph representation of our optimal control problem, we can use hypergraph partitioning to decompose the space-time structure. To do so, we use KaHyPar and the functions described in Partitioning and Graph Operations. the below code creates a hypergraph representation of the optigraph, sets up node and edge weights, partitions the problem, and forms new subgraphs based on the partitions.   We also aggregate the subgraphs to produce solvable optinode subproblems which will communicate to our solver.","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"#Import the KaHyPar interface\nusing KaHyPar         \n\n#Get the hypergraph representation of the gas network\nhypergraph,ref_map = gethypergraph(gas_network)     \n\n#Setup node and edge weights\nn_vertices = length(vertices(hypergraph))              \nnode_weights = [num_variables(node) for node in all_nodes(gas_network)]\nedge_weights = [num_link_constraints(edge) for edge in all_edges(gas_network)]  \n\n#Use KaHyPar to partition the hypergraph\nnode_vector = KaHyPar.partition(hypergraph,13,configuration = :edge_cut,\nimbalance = 0.01, node_weights = node_weights,edge_weights = edge_weights)      \n\n#Create a Partition object\npartition = Partition(gas_network,node_vector,ref_map)           \n\n#Setup subgraphs based on the partition\nmake_subgraphs!(gas_network,partition)             \n\n#Aggregate the subgraphs into OptiNodes which can be solved\nnew_graph , aggregate_map  = aggregate(gas_network,0)        ","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"The partitioned optimal control problem is visualized in the below figure and depicts the optimization problem partitioned into 13 distinct partitions.","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"(Image: partition)","category":"page"},{"location":"tutorials/tutorials/#Solution-with-PIPS-NLP","page":"Tutorials","title":"Solution with PIPS-NLP","text":"","category":"section"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"We finally solve the partitioned optigraph optimization problem using PipsSolver. The below code snippet distributes the optigraph among 13 worker MPI processes and solves the problem in parallel using the PIPS-NLP optimization solver.","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"using Distributed            \nusing MPIClusterManagers   \n\n# specify, number of mpi workers\nmanager=MPIManager(np=13)      \n# start mpi workers and add them as julia workers too.\naddprocs(manager)             \n\n#Setup the worker environments\n@everywhere using Plasmo      \n@everywhere using PipsSolver  \n\n#get the julia ids of the mpi workers\njulia_workers = collect(values(manager.mpi2j))\n\nremote_references = PipsSolver.distribute(new_graph,julia_workers,remote_name = :pips_graph)\n\n#Solve with PIPS-NLP\n@mpi_do manager begin   \n    using MPI\n    PipsSolver.pipsnlp_solve(pips_graph)\nend","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"This code snippet presents a standard template for setting up distributed computing environments to use PipsSolver.jl which is worth discussing. We use Julia's Distributed module as well as the MPIClusterManagers package which allows us to map MPI ranks (used by PIPS-NLP) with Julia worker CPUs. We then create a manager object and specify that we want to use 13 workers. Next we setup the model and solver environments for the added workers and create a reference to the julia workers by querying the manager.  We use PipsSolver to distribute the optigraph among the workers using the solver interface's distribute function. Internally, this function allocates optinodes to each worker, and creates the optigraph named pips_graph on each worker environment. Finally, we use the  @mpi_do function from MPIClusterManagers to execute MPI on each worker and solve the optigraph. Each worker executes the pipnlp_solve function and communicates using MPI within the PIPS-NLP solver.","category":"page"},{"location":"documentation/partitioning/#Partitioning-and-Graph-Operations","page":"Partitioning and Graph Operations","title":"Partitioning and Graph Operations","text":"","category":"section"},{"location":"documentation/partitioning/","page":"Partitioning and Graph Operations","title":"Partitioning and Graph Operations","text":"The Modeling section describes how to construct optigraphs using a bottom-up approach.  Specifically, we showed how to to use Hierarchical Modeling with subgraphs to create multi-level optigraphs. This part of the documentation deals with creating optigraphs using a top-down approach. Specifically, we show how to construct subgraphs using graph partitions and show how Plasmo.jl interfaces with standard graph partitioning tools such as Metis and KaHyPar.","category":"page"},{"location":"documentation/partitioning/#Example-Problem:-Dynamic-Optimization","page":"Partitioning and Graph Operations","title":"Example Problem: Dynamic Optimization","text":"","category":"section"},{"location":"documentation/partitioning/","page":"Partitioning and Graph Operations","title":"Partitioning and Graph Operations","text":"To help demonstrate graph partitioning capabilities in Plasmo.jl, we instantiate a simple optimal control problem described by the following equations. In this problem, x is a vector of states and u is a vector of control actions which are both indexed over the set of time indices t in 1T. The objective function minimizes the state trajectory with minimal control effort (energy), the second equation describes the state dynamics, and the third equation defines the initial condition. The last two equations define limits on the state and control actions.","category":"page"},{"location":"documentation/partitioning/","page":"Partitioning and Graph Operations","title":"Partitioning and Graph Operations","text":"    DocTestSetup = quote\n    using Plasmo\n\n    T = 100          #number of time points\n    d = sin.(1:T)    #disturbance vector\n\n    graph = OptiGraph()\n    @optinode(graph,state[1:T])\n    @optinode(graph,control[1:T-1])\n\n    for node in state\n        @variable(node,x)\n        @constraint(node, x >= 0)\n        @objective(node,Min,x^2)\n    end\n    for node in control\n        @variable(node,u)\n        @constraint(node, u >= -1000)\n        @objective(node,Min,u^2)\n    end\n\n    @linkconstraint(graph,[i = 1:T-1],state[i+1][:x] == state[i][:x] + control[i][:u] + d[i])\n    n1 = state[1]\n    @constraint(n1,n1[:x] == 0)\nend","category":"page"},{"location":"documentation/partitioning/","page":"Partitioning and Graph Operations","title":"Partitioning and Graph Operations","text":"beginaligned\n    min_ xu   sum_t = 1^T x_t^2 + u_t^2   \n    textrmst quad  x_t+1 = x_t + u_t + d_t quad t in 1T-1   \n     x_1 = 0  \n     x_t ge 0 quad t in 1T\n     u_t ge -1000 quad t in 1T-1\nendaligned","category":"page"},{"location":"documentation/partitioning/","page":"Partitioning and Graph Operations","title":"Partitioning and Graph Operations","text":"This snippet shows how to construct the optimal control problem in Plasmo.jl as described in Modeling. We create an optigraph, add optinodes which represent states and controls at each time period, we set objective functions for each optinode, and we use linking constraints to describe the dynamics.","category":"page"},{"location":"documentation/partitioning/","page":"Partitioning and Graph Operations","title":"Partitioning and Graph Operations","text":"using Plasmo\n\nT = 100          #number of time points\nd = sin.(1:T)    #disturbance vector\n\ngraph = OptiGraph()\n@optinode(graph,state[1:T])\n@optinode(graph,control[1:T-1])\n\nfor node in state\n    @variable(node,x)\n    @constraint(node, x >= 0)\n    @objective(node,Min,x^2)\nend\nfor node in control\n    @variable(node,u)\n    @constraint(node, u >= -1000)\n    @objective(node,Min,u^2)\nend\n\n@linkconstraint(graph,[i = 1:T-1],state[i+1][:x] == state[i][:x] + control[i][:u] + d[i])\nn1 = state[1]\n@constraint(n1,n1[:x] == 0)","category":"page"},{"location":"documentation/partitioning/","page":"Partitioning and Graph Operations","title":"Partitioning and Graph Operations","text":"When we print the newly created optigraph for our optimal control problem, we see it contains about 200 optinodes (one for each state and control) and contains almost 100 linking constraints (which couple the time periods).","category":"page"},{"location":"documentation/partitioning/","page":"Partitioning and Graph Operations","title":"Partitioning and Graph Operations","text":"julia> println(graph)\nOptiGraph:\nlocal nodes: 199, total nodes: 199\nlocal link constraints: 99, total link constraints 99\nlocal subgraphs: 0, total subgraphs 0","category":"page"},{"location":"documentation/partitioning/","page":"Partitioning and Graph Operations","title":"Partitioning and Graph Operations","text":"    DocTestSetup = nothing","category":"page"},{"location":"documentation/partitioning/","page":"Partitioning and Graph Operations","title":"Partitioning and Graph Operations","text":"We can also plot the resulting optigraph (see Plotting) which produces a simple chain, but otherwise there is no real structure in the problem as we have modeled it.","category":"page"},{"location":"documentation/partitioning/","page":"Partitioning and Graph Operations","title":"Partitioning and Graph Operations","text":"    using Plasmo\n\n    T = 100         \n    d = sin.(1:T)   \n\n    graph = OptiGraph()\n    @optinode(graph,state[1:T])\n    @optinode(graph,control[1:T-1])\n\n    for node in state\n        @variable(node,x)\n        @constraint(node, x >= 0)\n        @objective(node,Min,x^2)\n    end\n    for node in control\n        @variable(node,u)\n        @constraint(node, u >= -1000)\n        @objective(node,Min,u^2)\n    end\n\n    @linkconstraint(graph,[i = 1:T-1],state[i+1][:x] == state[i][:x] + control[i][:u] + d[i])\n    n1 = state[1]\n    @constraint(n1,n1[:x] == 0)","category":"page"},{"location":"documentation/partitioning/","page":"Partitioning and Graph Operations","title":"Partitioning and Graph Operations","text":"using Plots\nplt_chain = plt_graph4 = plot(graph,layout_options = Dict(:tol => 0.1,:iterations => 500), linealpha = 0.2,markersize = 6)\nPlots.savefig(plt_chain,\"chain_layout.svg\");\n\nplt_chain_matrix = spy(graph);\nPlots.savefig(plt_chain_matrix,\"chain_layout_matrix.svg\");","category":"page"},{"location":"documentation/partitioning/","page":"Partitioning and Graph Operations","title":"Partitioning and Graph Operations","text":"<img src=\"../chain_layout.svg\" alt=\"chain\" width=\"400\"/>","category":"page"},{"location":"documentation/partitioning/","page":"Partitioning and Graph Operations","title":"Partitioning and Graph Operations","text":"<img src=\"../chain_layout_matrix.svg\" alt=\"chain_matrix\" width=\"400\"/>","category":"page"},{"location":"documentation/partitioning/#Partitioning-OptiGraphs","page":"Partitioning and Graph Operations","title":"Partitioning OptiGraphs","text":"","category":"section"},{"location":"documentation/partitioning/","page":"Partitioning and Graph Operations","title":"Partitioning and Graph Operations","text":"At its core, the OptiGraph is a hypergraph and can thus naturally exploit hypergraph partitioning tools.   For our example here we demonstrate how to use hypergraph partitioning (using KaHyPar), but Plasmo.jl also facilitates using standard graph partitioning algorithms  (a hypergraph can be projected to various standard graph representations) or partitioning by manually defining partition vectors. The below snippet uses the gethypergraph function which returns a HyperGraph object and a hyper_map (a Julia dictionary) which maps hypernodes and hyperedges back to the original optigraph.","category":"page"},{"location":"documentation/partitioning/","page":"Partitioning and Graph Operations","title":"Partitioning and Graph Operations","text":"julia> hypergraph,hyper_map = gethypergraph(graph);\n\njulia> println(hypergraph)\nHypergraph: (199 , 99)","category":"page"},{"location":"documentation/partitioning/","page":"Partitioning and Graph Operations","title":"Partitioning and Graph Operations","text":"    DocTestSetup = quote\n    using Plasmo\n    using KaHyPar\n\n    T = 100         \n    d = sin.(1:T)   \n\n    graph = OptiGraph()\n    @optinode(graph,state[1:T])\n    @optinode(graph,control[1:T-1])\n\n    for node in state\n        @variable(node,x)\n        @constraint(node, x >= 0)\n        @objective(node,Min,x^2)\n    end\n    for node in control\n        @variable(node,u)\n        @constraint(node, u >= -1000)\n        @objective(node,Min,u^2)\n    end\n\n    @linkconstraint(graph,[i = 1:T-1],state[i+1][:x] == state[i][:x] + control[i][:u] + d[i])\n    n1 = state[1]\n    @constraint(n1,n1[:x] == 0)\n\n    hypergraph,hyper_map = gethypergraph(graph)\n    partition_vector = KaHyPar.partition(hypergraph,8,configuration = :connectivity,imbalance = 0.01)\n    partition = Partition(graph,partition_vector,hyper_map)\n    make_subgraphs!(graph,partition)\n    end","category":"page"},{"location":"documentation/partitioning/","page":"Partitioning and Graph Operations","title":"Partitioning and Graph Operations","text":"With our hypergraph we can now use KaHyPar to perform hypergraph partitioning in the next snippet which returns a partition_vector . Each index in the partition_vector corresponds to a hypernode index in hypergraph, and each value denotes which partition the hypernode belongs to.  So in our example, partition_vector contains 199 elements which can take on integer values between 0 and 7 (for 8 total partitions). Once we have a partition_vector, we can create a Partition object which describes sets (partitions) of optinodes and optiedges, as well as the shared optinodes and optiedges that cross partitions. We can lastly use the produced partition (a Partition object) to formulate subgraphs in our original optigraph (graph) using make_subgraphs!. After doing so, we see that our graph now contains 8 subgraphs with 7 linking constraints that correspond to the optiedges that cross partitions (i.e. connect subgraphs).","category":"page"},{"location":"documentation/partitioning/","page":"Partitioning and Graph Operations","title":"Partitioning and Graph Operations","text":"julia> using KaHyPar\n\njulia> partition_vector = KaHyPar.partition(hypergraph,8,configuration = :connectivity,imbalance = 0.01);\n\njulia> partition = Partition(graph,partition_vector,hyper_map);\n\njulia> make_subgraphs!(graph,partition);","category":"page"},{"location":"documentation/partitioning/","page":"Partitioning and Graph Operations","title":"Partitioning and Graph Operations","text":"julia> println(length(partition_vector))\n199\n\njulia> println(partition)\n    OptiGraph Partition w/ 8 subpartitions\n\njulia> println(length(getsubgraphs(graph)))\n8\n\njulia> num_linkconstraints(graph)\n7","category":"page"},{"location":"documentation/partitioning/","page":"Partitioning and Graph Operations","title":"Partitioning and Graph Operations","text":"    using Plasmo\n    using KaHyPar\n    using Plots\n\n    T = 100         \n    d = sin.(1:T)   \n\n    graph = OptiGraph()\n    @optinode(graph,state[1:T])\n    @optinode(graph,control[1:T-1])\n\n    for node in state\n        @variable(node,x)\n        @constraint(node, x >= 0)\n        @objective(node,Min,x^2)\n    end\n    for node in control\n        @variable(node,u)\n        @constraint(node, u >= -1000)\n        @objective(node,Min,u^2)\n    end\n\n    @linkconstraint(graph,[i = 1:T-1],state[i+1][:x] == state[i][:x] + control[i][:u] + d[i])\n    n1 = state[1]\n    @constraint(n1,n1[:x] == 0)\n\n    hypergraph,hyper_map = gethypergraph(graph);\n    partition_vector = KaHyPar.partition(hypergraph,8,configuration = :connectivity,imbalance = 0.01);\n    partition = Partition(graph,partition_vector,hyper_map);\n    make_subgraphs!(graph,partition);","category":"page"},{"location":"documentation/partitioning/","page":"Partitioning and Graph Operations","title":"Partitioning and Graph Operations","text":"If we plot the partitioned optigraph, it reveals eight distinct partitions and the coupling between them. The plots show that the partitions are well-balanced and the matrix visualization shows the problem is reordered into a banded structure that is typical of dynamic optimization problems.","category":"page"},{"location":"documentation/partitioning/","page":"Partitioning and Graph Operations","title":"Partitioning and Graph Operations","text":"plt_chain_partition = plot(graph,layout_options = Dict(:tol => 0.01, :iterations => 500),linealpha = 0.2,markersize = 6,subgraph_colors = true);\nPlots.savefig(plt_chain_partition,\"chain_layout_partition.svg\");\n\nplt_chain_matrix_partition = spy(graph,subgraph_colors = true);\nPlots.savefig(plt_chain_matrix_partition,\"chain_layout_matrix_partition.svg\");","category":"page"},{"location":"documentation/partitioning/","page":"Partitioning and Graph Operations","title":"Partitioning and Graph Operations","text":"<img src=\"../chain_layout_partition.svg\" alt=\"chain_partition\" width=\"400\"/>","category":"page"},{"location":"documentation/partitioning/","page":"Partitioning and Graph Operations","title":"Partitioning and Graph Operations","text":"<img src=\"../chain_layout_matrix_partition.svg\" alt=\"chain_matrix_partition\" width=\"400\"/>","category":"page"},{"location":"documentation/partitioning/#Aggregating-OptiGraphs","page":"Partitioning and Graph Operations","title":"Aggregating OptiGraphs","text":"","category":"section"},{"location":"documentation/partitioning/","page":"Partitioning and Graph Operations","title":"Partitioning and Graph Operations","text":"Subgraphs can be converted into stand-alone optinodes using the using the aggregate function. This is important from a solver stand-point because optinodes represent solvable subproblems which can be communicated to decomposition algorithms. This aggregation step also takes place when using standard optimization solvers with Plasmo.jl, such as Ipopt wherein the optigraph is aggregated into a single optinode and solved using the underlying JuMP interface. In the snippet below, we aggregate our optigraph that contains 8 subgraphs.  We include the argument 0 which specifies how many subgraph levels to retain.  In this case, 0 means we aggregate subgraphs at the highest level so graph contains only new aggregated optinodes. For hierarchical graphs with many levels, we can define how many subgraph levels we wish to retain. The function returns a new aggregated graph (aggregate_graph), as well as reference_map which maps variables in aggregate_graph to the original optigraph graph.","category":"page"},{"location":"documentation/partitioning/","page":"Partitioning and Graph Operations","title":"Partitioning and Graph Operations","text":"julia> aggregate_graph,reference_map = aggregate(graph,0);\nCreating Combined OptiGraph with a maximum subgraph depth of 0\n\njulia> println(aggregate_graph)\nOptiGraph:\nlocal nodes: 8, total nodes: 8\nlocal link constraints: 7, total link constraints 7\nlocal subgraphs: 0, total subgraphs 0","category":"page"},{"location":"documentation/partitioning/","page":"Partitioning and Graph Operations","title":"Partitioning and Graph Operations","text":"    using Plasmo\n    using KaHyPar\n    using Plots\n\n    T = 100         \n    d = sin.(1:T)   \n\n    graph = OptiGraph()\n    @optinode(graph,state[1:T])\n    @optinode(graph,control[1:T-1])\n\n    for node in state\n        @variable(node,x)\n        @constraint(node, x >= 0)\n        @objective(node,Min,x^2)\n    end\n    for node in control\n        @variable(node,u)\n        @constraint(node, u >= -1000)\n        @objective(node,Min,u^2)\n    end\n\n    @linkconstraint(graph,[i = 1:T-1],state[i+1][:x] == state[i][:x] + control[i][:u] + d[i])\n    n1 = state[1]\n    @constraint(n1,n1[:x] == 0)\n\n    hypergraph,hyper_map = gethypergraph(graph);\n    partition_vector = KaHyPar.partition(hypergraph,8,configuration = :connectivity,imbalance = 0.01);\n    partition = Partition(graph,partition_vector,hyper_map);\n    make_subgraphs!(graph,partition);\n\n    aggregate_graph,reference_map = aggregate(graph,0);","category":"page"},{"location":"documentation/partitioning/","page":"Partitioning and Graph Operations","title":"Partitioning and Graph Operations","text":"We can lastly plot the aggregated graph structure which simply shows 8 optinodes with 7 linking constraints.","category":"page"},{"location":"documentation/partitioning/","page":"Partitioning and Graph Operations","title":"Partitioning and Graph Operations","text":"plt_chain_aggregate = plot(aggregate_graph,layout_options = Dict(:tol => 0.01,:iterations => 10),node_labels = true,markersize = 30,labelsize = 20,node_colors = true);\nPlots.savefig(plt_chain_aggregate,\"chain_layout_aggregate.svg\");\n\nplt_chain_matrix_aggregate = spy(aggregate_graph,node_labels = true,node_colors = true);\nPlots.savefig(plt_chain_matrix_aggregate,\"chain_layout_matrix_aggregate.svg\");","category":"page"},{"location":"documentation/partitioning/","page":"Partitioning and Graph Operations","title":"Partitioning and Graph Operations","text":"<img src=\"../chain_layout_aggregate.svg\" alt=\"chain_aggregate\" width=\"400\"/>","category":"page"},{"location":"documentation/partitioning/","page":"Partitioning and Graph Operations","title":"Partitioning and Graph Operations","text":"<img src=\"../chain_layout_matrix_aggregate.svg\" alt=\"chain_matrix_aggregate\" width=\"400\"/>","category":"page"},{"location":"documentation/partitioning/#Methods","page":"Partitioning and Graph Operations","title":"Methods","text":"","category":"section"},{"location":"documentation/partitioning/","page":"Partitioning and Graph Operations","title":"Partitioning and Graph Operations","text":"Partition\nmake_subgraphs!\naggregate\nexpand\nPlasmo.neighborhood\nHyperGraph\ngethypergraph","category":"page"},{"location":"documentation/partitioning/#Plasmo.Partition","page":"Partitioning and Graph Operations","title":"Plasmo.Partition","text":"Partition(hypergraph::HyperGraph,node_membership_vector::Vector{Int64},ref_map::Dict)\n\nCreate a partition of optinodes using hypergraph, node_membership_vector, and 'refmap'.  The 'refmap' is a dictionary that maps hypernode indices (integers) and hyperedge indices (tuples) back to optinodes and optiedges.\n\nPartition(optigraph::OptiGraph,node_membership_vector::Vector{Int64},ref_map::Dict)\n\nCreate a partition using optigraph, node_membership_vector, and 'refmap'. The `refmap` is a mapping of node_indices to the original optinodes.\n\nPartition(optigraph::OptiGraph,optinode_vectors::Vector{Vector{OptiNode}})\n\nManually create a partition using optigraph and a vector of vectors containing sets of optinodes that represent each partition.\n\n\n\n\n\n","category":"type"},{"location":"documentation/partitioning/#Plasmo.make_subgraphs!","page":"Partitioning and Graph Operations","title":"Plasmo.make_subgraphs!","text":"make_subgraphs!(optigraph::OptiGraph,partition::Partition)\n\nCreate subgraphs in optigraph using a produced 'partition'.\n\n\n\n\n\n","category":"function"},{"location":"documentation/partitioning/#Plasmo.aggregate","page":"Partitioning and Graph Operations","title":"Plasmo.aggregate","text":"aggregate(graph::OptiGraph)\n\nAggregate the optigraph graph into a new optinode.  Return an optinode and a dictionary which maps optinode variable and constraint references to the original optigraph.\n\naggregate(graph::OptiGraph,max_depth::Int64)\n\nAggregate the optigraph 'graph' into a new aggregated optigraph. Return a newly aggregated optigraph and a dictionary which maps new variables and constraints to the original optigraph. max_depth determines how many levels of subgraphs remain in the new aggregated optigraph. For example, a max_depth of 0 signifies there should be no subgraphs in the aggregated optigraph.\n\n\n\n\n\n","category":"function"},{"location":"documentation/partitioning/#Plasmo.expand","page":"Partitioning and Graph Operations","title":"Plasmo.expand","text":"expand(graph::OptiGraph,subgraph::OptiGraph,distance::Int64)\n\nReturn a new expanded subgraph given the optigraph graph and an existing subgraph subgraph. The returned subgraph contains the expanded neighborhood within distance of the given subgraph.\n\n\n\n\n\n","category":"function"},{"location":"documentation/partitioning/#Plasmo.neighborhood","page":"Partitioning and Graph Operations","title":"Plasmo.neighborhood","text":"neighborhood(graph::OptiGraph,nodes::Vector{OptiNode},distance::Int64)::Vector{OptiNode}\n\nReturn the optinodes within distance of the given nodes in the optigraph graph.\n\n\n\n\n\n","category":"function"},{"location":"documentation/partitioning/#Plasmo.HyperGraph","page":"Partitioning and Graph Operations","title":"Plasmo.HyperGraph","text":"Hypergraph\n\nA simple hypergraph type.  Contains attributes for vertices and hyperedges.\n\n\n\n\n\n","category":"type"},{"location":"documentation/partitioning/#Plasmo.gethypergraph","page":"Partitioning and Graph Operations","title":"Plasmo.gethypergraph","text":"gethypergraph(graph::OptiGraph)\n\nRetrieve a hypergraph representation of the optigraph graph. Returns a HyperGraph object, as well as a dictionary that maps hypernodes and hyperedges to the original optinodes and optiedges.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: Plasmo logo)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"CurrentModule = Plasmo\nDocTestSetup = quote\n    using Plasmo\n    using GLPK\n    using Plots\nend","category":"page"},{"location":"#Plasmo.jl-Platform-for-Scalable-Modeling-and-Optimization","page":"Introduction","title":"Plasmo.jl - Platform for Scalable Modeling and Optimization","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Plasmo.jl is a graph-based optimization framework written in Julia that adopts a modular modeling style to construct and solve optimization problems. The package builds upon the modeling framework JuMP.jl to create graph-structured optimization models and works at a higher level of abstraction which facilitates hierarchical modeling and graph-based operations such as partitioning. More specifically, Plasmo.jl implements what is called the OptiGraph abstraction to construct optimization models. An OptiGraph captures the underlying topology of an optimization problem using OptiNodes (which represent stand-alone optimization models) that are coupled by means of OptiEdges (which correspond to coupling constraints). The resulting graph topology enables systematic model construction and can be exploited for various modeling tasks and the development of distributed optimization algorithms.  ","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The Plasmo.jl package works for Julia versions 1.0 and later. From Julia, Plasmo.jl can be installed using the built-in package manager:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"import Pkg\nPkg.add(\"Plasmo\")","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"or alternatively from the Julia 1.0 package manager, one can simply do:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"] add Plasmo","category":"page"},{"location":"#Quickstart-Example","page":"Introduction","title":"Quickstart Example","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This quickstart example gives a brief overview of the functions needed to effectively use Plasmo.jl to build optimization models. If you are familiar with JuMP, much of the functionality you see here will be equivalent.  In fact, the primary OptiGraph object is an extension of the JuMP.AbstractModel, as well as its contained OptiNodes.  ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The below example demonstrates the construction of a simple nonlinear optimization problem that contains two OptiNodes coupled by a simple LinkConstraint (which creates an OptiEdge) and solved with the linear optimization solver GLPK. More detailed examples can be found in the examples folder.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Once Plasmo.jl has been installed, you can use it from a Julia session as following:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> using Plasmo","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"For this example we also need to import the GLPK optimization solver and the Plots package which we use to visualize graph structure.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> using GLPK\njulia> using Plots","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"note: Note\nWe highlight that it is possible to use any solver that works with JuMP. By default, when using a standard optimization solver available through JuMP, Plasmo.jl will aggregate the OptiGraph into a single node to solve (hence ignoring the graph structure).  While it is useful having such granular control to build optimization models with an OptiGraph, we note that this aggregation step introduces additional model-building time when using standard optimization solvers (such as GLPK and Ipopt).","category":"page"},{"location":"#Create-an-OptiGraph","page":"Introduction","title":"Create an OptiGraph","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The following command will create an OptiGraph model.  We also see the printed output which denotes the number of optinodes, linking constraints, and subgraphs within the OptiGraph.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> graph = OptiGraph()\nOptiGraph:\nlocal nodes: 0, total nodes: 0\nlocal link constraints: 0, total link constraints 0\nlocal subgraphs: 0, total subgraphs 0","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"note: Note\nAn OptiGraph distinguishes between local and total entities (i.e. nodes, edges, link constraints, and subgraphs). This distinction between local and total is used to describe hierarchical graph structures which are introduced in Hierarchical Modeling.","category":"page"},{"location":"#Add-OptiNodes","page":"Introduction","title":"Add OptiNodes","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"An OptiGraph consists of OptiNodes which contain stand-alone optimization models. An OptiNode extends a JuMP.AbstractModel (and also a wraps a JuMP.Model) and supports the same macros to create variables, constraints, and add objective functions (using @variable, @constraint, and @objective).  To add optinodes to a graph, one can simply use the @optinode macro as shown in the following code snippet. For this example, we create the OptiNode n1, we create two variables x and y, and add a single constraint and an objective function.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> @optinode(graph,n1)\nOptiNode w/ 0 Variable(s)\n\njulia> @variable(n1, y >= 2)\ny\n\njulia> @variable(n1, x >= 0)\nx\n\njulia> @constraint(n1,x + y >= 3)\nx + y >= 3\n\njulia> @objective(n1, Min, y)\ny","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"DocTestSetup = nothing","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"    DocTestSetup = quote\n    using Plasmo\n    using GLPK\n    using Plots\n\n    graph = OptiGraph()\n    @optinode(graph,n1)\n    @variable(n1, y >= 2)\n    @variable(n1,x >= 0)\n    @constraint(n1,x + y >= 3)\n    @objective(n1, Min, y)\n\n    @optinode(graph,n2);\n    @variable(n2, y >= 0);\n    @variable(n2, x >= 0);\n    @constraint(n2,x + y >= 3);\n    @objective(n2, Min, y);\n\n    @optinode(graph,n3);\n    @variable(n3, y >= 0);\n    @variable(n3,x >= 0);\n    @constraint(n3,x + y >= 3);\n    @objective(n3, Min, y);  \nend","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"We can create more OptiNodes and add variables, constraints, and objective functions to each node in the graph.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> @optinode(graph,n2);\njulia> @variable(n2, y >= 0);\njulia> @variable(n2,x >= 0);\njulia> @constraint(n2,x + y >= 3);\njulia> @objective(n2, Min, y);\n\njulia> @optinode(graph,n3);\njulia> @variable(n3, y >= 0);\njulia> @variable(n3,x >= 0);\njulia> @constraint(n3,x + y >= 3);\njulia> @objective(n3, Min, y);  ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> println(graph)\nOptiGraph:\nlocal nodes: 3, total nodes: 3\nlocal link constraints: 0, total link constraints 0\nlocal subgraphs: 0, total subgraphs 0","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"DocTestSetup = nothing","category":"page"},{"location":"#Create-LinkConstraints-(OptiEdges)","page":"Introduction","title":"Create LinkConstraints (OptiEdges)","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Linking constraints can be used to couple variables between optinodes.  Beneath the modeling surface, creating a linking constraint induces an OptiEdge in the OptiGraph which describes its connectivity.  Linking constraints are created using the @linkconstraint macro which takes the exact same input as the JuMP.@constraint macro.  The following code creates a linking constraint between variables on the three optinodes.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> @linkconstraint(graph, n1[:x] + n2[:x] + n3[:x] == 3)\nLinkConstraintRef(1, OptiEdge w/ 1 Constraint(s))\n\njulia> println(graph)\nOptiGraph:\nlocal nodes: 3, total nodes: 3\nlocal link constraints: 1, total link constraints 1\nlocal subgraphs: 0, total subgraphs 0","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"note: Note\nNonlinear linking constraints are not yet supported","category":"page"},{"location":"#Solve-and-Query-Solution","page":"Introduction","title":"Solve and Query Solution","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"When using a JuMP/MOI enabled optimization solver, we can optimize an OptiGraph using the optimize! function extended from JuMP.   As mentioned earlier, Plasmo.jl aggregates the graph into a single model (an optinode), hands off the problem to JuMP and the chosen solver, and then populates the OptiGraph solution.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> optimize!(graph,GLPK.Optimizer)\nConverting OptiGraph to OptiNode...\nOptimizing OptiNode\nFound Solution","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"After finding a solution, we can query it using value(::OptiNode,::VariableRef) extended from JuMP.   We can also query the objective value of the graph using objective_value(::OptiGraph)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> value(n1,n1[:x])    \n1.0\n\njulia> value(n2,n2[:x])\n2.0\n\njulia> value(n3,n3[:x])\n0.0\n\njulia> objective_value(graph)\n6.0","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"note: Note\nPlasmo.jl assumes the objective function of each optinode is added by default.  The objective function for an optigraph can be changed using the @objective macro on the optigraph itself.","category":"page"},{"location":"#Visualize-the-Structure","page":"Introduction","title":"Visualize the Structure","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"    using Plasmo\n    using Plots\n\n    graph = OptiGraph()\n    @optinode(graph,n1)\n    @variable(n1, y >= 2)\n    @variable(n1,x >= 0)\n    @constraint(n1,x + y >= 3)\n    @objective(n1, Min, y)\n\n    @optinode(graph,n2);\n    @variable(n2, y >= 0);\n    @variable(n2,x >= 0);\n    @constraint(n2,x + y >= 3);\n    @objective(n2, Min, y);\n\n    @optinode(graph,n3);\n    @variable(n3, y >= 0);\n    @variable(n3, x >= 0);\n    @constraint(n3,x + y >= 3);\n    @objective(n3, Min, y);  \n\n    @linkconstraint(graph, n1[:x] + n2[:x] + n3[:x] == 3);","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Lastly, it is often useful to be able to visualize the structure of an OptiGraph object.  Doing such a visualization can lead to physical insights about an optimization problem (such as space-time dependencies), but it is also helpful just to see the connectivity of the problem.  Plasmo.jl uses Plots.jl and NetworkLayout.jl to visualize the layout of an OptiGraph.  The code here shows how to obtain the graph topology using Plots.plot(::OptiGraph) and we plot the underlying adjacency matrix structure using Plots.spy function. Both of these functions can accept keyword arguments to customize their layout or appearance. The matrix visualization also encodes information on the number of variables and constraints in each node and edge. The left figure shows a standard graph visualization where we draw an edge between each pair of nodes if they share an edge, and the rightfigure shows the matrix representation where labeled blocks correspond to nodes and blue marks represent linking constraints that connect their variables. The node layout helps visualize the overall connectivity of the graph while the matrix layout helps visualize the size of nodes and edges.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"plt_graph = Plots.plot(graph,node_labels = true, markersize = 30,labelsize = 15, linewidth = 4,layout_options = Dict(:tol => 0.01,:iterations => 2),plt_options = Dict(:legend => false,:framestyle => :box,:grid => false,:size => (400,400),:axis => nothing));\n\nPlots.savefig(plt_graph,\"graph_layout.svg\");\n\nplt_matrix = Plots.spy(graph,node_labels = true,markersize = 15);   \n\nPlots.savefig(plt_matrix,\"matrix_layout.svg\");","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"<img src=\"graph_layout.svg\" alt=\"graph\" width=\"400\"/>","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"<img src=\"matrix_layout.svg\" alt=\"matrix\" width=\"400\"/>","category":"page"},{"location":"#Contents","page":"Introduction","title":"Contents","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\n    \"documentation/modeling.md\"\n    \"documentation/partitioning.md\"\n    \"documentation/solvers.md\"\n    \"documentation/plotting.md\"\n    ]\nDepth = 2","category":"page"},{"location":"#Future-Development","page":"Introduction","title":"Future Development","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"There are currently a few major development avenues for Plasmo.jl. Here is a list of some of the major features we intend to add for future releases:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Parallel modeling capabilities\nNonlinear linking constraints\nGraph metrics and custom partitioning algorithms\nMore distributed solver support","category":"page"},{"location":"#Index","page":"Introduction","title":"Index","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"#Citing-Plasmo.jl","page":"Introduction","title":"Citing Plasmo.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"If you find Plasmo.jl useful for your work, you may cite the current pre-print:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@misc{JalvingShinZavala2020,\ntitle = {A Graph-Based Modeling Abstraction for Optimization: Concepts and Implementation in Plasmo.jl},\nauthor = {Jordan Jalving and Sungho Shin and Victor M. Zavala},\nyear = {2020},\neprint = {2006.05378},\narchivePrefix = {arXiv},\nprimaryClass = {math.OC}\n}","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"There is also an earlier manuscript where we presented the initial ideas behind Plasmo.jl which you can find here:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@article{JalvingCaoZavala2019,\nauthor = {Jalving, Jordan and Cao, Yankai and Zavala, Victor M},\njournal = {Computers {\\&} Chemical Engineering},\npages = {134--154},\ntitle = {Graph-based modeling and simulation of complex systems},\nvolume = {125},\nyear = {2019},\ndoi = {https://doi.org/10.1016/j.compchemeng.2019.03.009}\n}","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A pre-print of this paper can also be found here","category":"page"}]
}
